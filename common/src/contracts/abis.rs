// WARNING! The rest of this module was auto-generated from a combination of built contract abis,
// and a proc_macro. The choice to put the autogenerated code here oldschool style is because
// it is not yet reasonable to try and build the contracts or pull in an npm dependency as a part
// of the build process, and the proc_macro itself doesn't have a way to describe that the dependencies
// changed. One advantage of putting the generated file here is that is is more browsable and IDE friendly
//
// To regenerate when either the contracts or solidity_bindgen changes:
// 1. Rebuild the contracts:
//    a. npm install
//       If you get the error "'@graphprotocol/common-ts@0.0.31' is not in the npm registry." then:
//          Create an npm account
//          Have someone add you to the graphprotocol npm organization
//          `npm login` locally and try again
//    b. npm run compile
//    c. npm run abi:extract
// 2. Delete all the "live" auto-generated code in this file.
// 3. Uncomment the below macro invocation, modifying the path to be a relative directory from
//    the workspace to the /build/abis directory created in step 1.b
// 4. Using `cargo-expand contracts::abis > temp.rs`, output the expanded proc macro to a temporary file
// 5. Copy the contents of the temporary file created in step 4 here, leaving the instructions intact
// 7. Remove the unnecessary mod created by cargo_expand
// 8. Comment out the proc_macro invocation again.
// 9. Run cargo fmt
// It aint pretty, but it works.
#![allow(
    dead_code,
    non_camel_case_types,
    clippy::too_many_arguments,
    clippy::type_complexity
)]
//solidity_bindgen::contract_abis!("../contracts/build/abis/");

pub struct IController<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IController<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IController<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_id\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getContractProxy\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"getGovernor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"partialPaused\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"paused\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_id\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_contractAddress\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setContractProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_partialPaused\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setPartialPaused\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newPauseGuardian\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setPauseGuardian\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_paused\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setPaused\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_id\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"unsetContractProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_id\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"updateController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IController<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_contract_proxy(
        &self,
        id: [u8; 32usize],
        contract_address: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setContractProxy", (id, contract_address), None, None)
            .await
    }
    pub async fn update_controller(
        &self,
        id: [u8; 32usize],
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("updateController", (id, controller), None, None)
            .await
    }
    pub async fn unset_contract_proxy(
        &self,
        id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("unsetContractProxy", id, None, None)
            .await
    }
    pub async fn set_partial_paused(
        &self,
        partial_paused: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setPartialPaused", partial_paused, None, None)
            .await
    }
    pub async fn set_paused(
        &self,
        paused: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("setPaused", paused, None, None).await
    }
    pub async fn set_pause_guardian(
        &self,
        new_pause_guardian: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setPauseGuardian", new_pause_guardian, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IController<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn partial_paused(&self) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("partialPaused", ()).await
    }
    pub async fn paused(&self) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("paused", ()).await
    }
    pub async fn get_contract_proxy(
        &self,
        id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("getContractProxy", id).await
    }
    pub async fn get_governor(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("getGovernor", ()).await
    }
}
pub struct IENS<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IENS<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IENS<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"node\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"owner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"node\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"label\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"resolver\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"ttl\",\n        \"type\": \"uint64\"\n      }\n    ],\n    \"name\": \"setSubnodeRecord\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IENS<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_subnode_record(
        &self,
        node: [u8; 32usize],
        label: [u8; 32usize],
        owner: ::web3::types::Address,
        resolver: ::web3::types::Address,
        ttl: u64,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setSubnodeRecord",
                (node, label, owner, resolver, ttl),
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> IENS<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn owner(
        &self,
        node: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("owner", node).await
    }
}
pub struct GraphUpgradeable<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GraphUpgradeable<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GraphUpgradeable<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"acceptProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptProxyAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GraphUpgradeable<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn accept_proxy(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptProxy", proxy, None, None).await
    }
    pub async fn accept_proxy_and_call(
        &self,
        proxy: ::web3::types::Address,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptProxyAndCall", (proxy, data), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> GraphUpgradeable<SolidityBindgenProvider> where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider
{
}
pub struct GraphProxyAdmin<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GraphProxyAdmin<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GraphProxyAdmin<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewPendingOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"acceptOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract GraphUpgradeable\",\n        \"name\": \"_implementation\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"acceptProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract GraphUpgradeable\",\n        \"name\": \"_implementation\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptProxyAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newAdmin\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"changeProxyAdmin\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getProxyAdmin\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getProxyImplementation\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getProxyPendingImplementation\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"governor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingGovernor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newGovernor\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_implementation\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"upgrade\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GraphProxyAdmin<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn accept_ownership(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptOwnership", (), None, None).await
    }
    pub async fn transfer_ownership(
        &self,
        new_governor: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferOwnership", new_governor, None, None)
            .await
    }
    pub async fn accept_proxy_and_call(
        &self,
        implementation: ::web3::types::Address,
        proxy: ::web3::types::Address,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "acceptProxyAndCall",
                (implementation, proxy, data),
                None,
                None,
            )
            .await
    }
    pub async fn upgrade(
        &self,
        proxy: ::web3::types::Address,
        implementation: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("upgrade", (proxy, implementation), None, None)
            .await
    }
    pub async fn accept_proxy(
        &self,
        implementation: ::web3::types::Address,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptProxy", (implementation, proxy), None, None)
            .await
    }
    pub async fn change_proxy_admin(
        &self,
        proxy: ::web3::types::Address,
        new_admin: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("changeProxyAdmin", (proxy, new_admin), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> GraphProxyAdmin<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn governor(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("governor", ()).await
    }
    pub async fn pending_governor(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("pendingGovernor", ()).await
    }
    pub async fn get_proxy_pending_implementation(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider
            .call("getProxyPendingImplementation", proxy)
            .await
    }
    pub async fn get_proxy_admin(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("getProxyAdmin", proxy).await
    }
    pub async fn get_proxy_implementation(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("getProxyImplementation", proxy).await
    }
}
pub struct GraphToken<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GraphToken<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GraphToken<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_initialSupply\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"MinterAdded\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"MinterRemoved\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewPendingOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"acceptOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"addMinter\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burn\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burnFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"subtractedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"decreaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"governor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"addedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"increaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isMinter\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"nonces\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingGovernor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_deadline\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"_v\",\n        \"type\": \"uint8\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_r\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_s\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"permit\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"removeMinter\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"renounceMinter\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newGovernor\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GraphToken<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn transfer_ownership(
        &self,
        new_governor: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferOwnership", new_governor, None, None)
            .await
    }
    pub async fn add_minter(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("addMinter", account, None, None).await
    }
    pub async fn remove_minter(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("removeMinter", account, None, None)
            .await
    }
    pub async fn burn_from(
        &self,
        account: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("burnFrom", (account, amount), None, None)
            .await
    }
    pub async fn transfer_from(
        &self,
        sender: ::web3::types::Address,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferFrom", (sender, recipient, amount), None, None)
            .await
    }
    pub async fn burn(
        &self,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("burn", amount, None, None).await
    }
    pub async fn transfer(
        &self,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transfer", (recipient, amount), None, None)
            .await
    }

    pub async fn permit(
        &self,
        owner: ::web3::types::Address,
        spender: ::web3::types::Address,
        value: ::web3::types::U256,
        deadline: ::web3::types::U256,
        v: u8,
        r: [u8; 32usize],
        s: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "permit",
                (owner, spender, value, deadline, v, r, s),
                None,
                None,
            )
            .await
    }
    pub async fn mint(
        &self,
        to: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("mint", (to, amount), None, None).await
    }
    pub async fn increase_allowance(
        &self,
        spender: ::web3::types::Address,
        added_value: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("increaseAllowance", (spender, added_value), None, None)
            .await
    }
    pub async fn approve(
        &self,
        spender: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("approve", (spender, amount), None, None)
            .await
    }
    pub async fn decrease_allowance(
        &self,
        spender: ::web3::types::Address,
        subtracted_value: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("decreaseAllowance", (spender, subtracted_value), None, None)
            .await
    }
    pub async fn renounce_minter(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("renounceMinter", (), None, None).await
    }
    pub async fn accept_ownership(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptOwnership", (), None, None).await
    }
}
impl<SolidityBindgenProvider> GraphToken<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn symbol(&self) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("symbol", ()).await
    }
    pub async fn balance_of(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("balanceOf", account).await
    }
    pub async fn name(&self) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("name", ()).await
    }
    pub async fn pending_governor(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("pendingGovernor", ()).await
    }
    pub async fn decimals(&self) -> ::std::result::Result<u8, ::web3::Error> {
        self.provider.call("decimals", ()).await
    }
    pub async fn is_minter(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isMinter", account).await
    }
    pub async fn allowance(
        &self,
        owner: ::web3::types::Address,
        spender: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("allowance", (owner, spender)).await
    }
    pub async fn governor(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("governor", ()).await
    }
    pub async fn nonces(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("nonces", input_0).await
    }
    pub async fn total_supply(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("totalSupply", ()).await
    }
}
pub struct GNSV1Storage<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GNSV1Storage<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GNSV1Storage<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"bondingCurve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"erc1056Registry\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IEthereumDIDRegistry\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"graphAccountSubgraphNumbers\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"nameSignals\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"vSignal\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"nSignal\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"reserveRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"disabled\",\n        \"type\": \"bool\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"withdrawableGRT\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"ownerTaxPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"subgraphs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GNSV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> GNSV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn bonding_curve(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("bondingCurve", ()).await
    }
    pub async fn owner_tax_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("ownerTaxPercentage", ()).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn erc_1056_registry(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("erc1056Registry", ()).await
    }
    pub async fn graph_account_subgraph_numbers(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("graphAccountSubgraphNumbers", input_0)
            .await
    }
    pub async fn subgraphs(
        &self,
        input_0: ::web3::types::Address,
        input_1: ::web3::types::U256,
    ) -> ::std::result::Result<[u8; 32usize], ::web3::Error> {
        self.provider.call("subgraphs", (input_0, input_1)).await
    }
    pub async fn name_signals(
        &self,
        input_0: ::web3::types::Address,
        input_1: ::web3::types::U256,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            [u8; 32usize],
            u32,
            bool,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("nameSignals", (input_0, input_1)).await
    }
}
pub struct IStaking<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IStaking<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IStaking<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"allocate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"allocateFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_restake\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"claim\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address[]\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address[]\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_restake\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"claimMany\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_poi\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"closeAllocation\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"address\",\n            \"name\": \"allocationID\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"poi\",\n            \"type\": \"bytes32\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.CloseAllocationRequest[]\",\n        \"name\": \"_requests\",\n        \"type\": \"tuple[]\"\n      }\n    ],\n    \"name\": \"closeAllocationMany\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_oldAllocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_poi\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"closeAndAllocate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"collect\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"delegate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getAllocation\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"address\",\n            \"name\": \"indexer\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokens\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"createdAtEpoch\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"closedAtEpoch\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"collectedFees\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"effectiveAllocation\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"accRewardsPerAllocatedToken\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.Allocation\",\n        \"name\": \"\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getAllocationState\",\n    \"outputs\": [\n      {\n        \"internalType\": \"enum IStaking.AllocationState\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_delegator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getDelegation\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"shares\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLocked\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLockedUntil\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.Delegation\",\n        \"name\": \"\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getIndexerCapacity\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getIndexerStakedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getSubgraphAllocatedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"hasStake\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isAllocation\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_delegator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isDelegator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isOperator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_assetHolder\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setAssetHolder\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_channelDisputeEpochs\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setChannelDisputeEpochs\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setCurationPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_indexingRewardCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_queryFeeCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_cooldownBlocks\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationParameters\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_blocks\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationParametersCooldown\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationRatio\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationTaxPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationUnbondingPeriod\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationUnbondingPeriod\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_maxAllocationEpochs\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setMaxAllocationEpochs\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumIndexerStake\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setMinimumIndexerStake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setOperator\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setProtocolPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setRebateRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_destination\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setRewardsDestination\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_slasher\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setSlasher\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_thawingPeriod\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setThawingPeriod\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_reward\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_beneficiary\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"slash\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"stake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"stakeTo\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"undelegate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"unstake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newIndexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"withdrawDelegated\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IStaking<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_delegation_tax_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationTaxPercentage", percentage, None, None)
            .await
    }
    pub async fn unstake(
        &self,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("unstake", tokens, None, None).await
    }
    pub async fn set_rewards_destination(
        &self,
        destination: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setRewardsDestination", destination, None, None)
            .await
    }
    pub async fn close_and_allocate(
        &self,
        old_allocation_id: ::web3::types::Address,
        poi: [u8; 32usize],
        indexer: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "closeAndAllocate",
                (
                    old_allocation_id,
                    poi,
                    indexer,
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn set_minimum_indexer_stake(
        &self,
        minimum_indexer_stake: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setMinimumIndexerStake", minimum_indexer_stake, None, None)
            .await
    }
    pub async fn undelegate(
        &self,
        indexer: ::web3::types::Address,
        shares: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("undelegate", (indexer, shares), None, None)
            .await
    }
    pub async fn claim(
        &self,
        allocation_id: ::web3::types::Address,
        restake: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("claim", (allocation_id, restake), None, None)
            .await
    }
    pub async fn set_channel_dispute_epochs(
        &self,
        channel_dispute_epochs: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setChannelDisputeEpochs",
                channel_dispute_epochs,
                None,
                None,
            )
            .await
    }
    pub async fn withdraw(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("withdraw", (), None, None).await
    }
    pub async fn set_slasher(
        &self,
        slasher: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setSlasher", (slasher, allowed), None, None)
            .await
    }
    pub async fn set_delegation_unbonding_period(
        &self,
        delegation_unbonding_period: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setDelegationUnbondingPeriod",
                delegation_unbonding_period,
                None,
                None,
            )
            .await
    }
    pub async fn collect(
        &self,
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("collect", (tokens, allocation_id), None, None)
            .await
    }
    pub async fn allocate(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "allocate",
                (
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn withdraw_delegated(
        &self,
        indexer: ::web3::types::Address,
        new_indexer: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("withdrawDelegated", (indexer, new_indexer), None, None)
            .await
    }
    pub async fn delegate(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("delegate", (indexer, tokens), None, None)
            .await
    }
    pub async fn close_allocation(
        &self,
        allocation_id: ::web3::types::Address,
        poi: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("closeAllocation", (allocation_id, poi), None, None)
            .await
    }
    pub async fn slash(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
        reward: ::web3::types::U256,
        beneficiary: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("slash", (indexer, tokens, reward, beneficiary), None, None)
            .await
    }
    pub async fn allocate_from(
        &self,
        indexer: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "allocateFrom",
                (
                    indexer,
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn close_allocation_many(
        &self,
        requests: ::solidity_bindgen::internal::Unimplemented,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("closeAllocationMany", requests, None, None)
            .await
    }
    pub async fn claim_many(
        &self,
        allocation_id: ::std::vec::Vec<::web3::types::Address>,
        restake: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("claimMany", (allocation_id, restake), None, None)
            .await
    }
    pub async fn set_delegation_parameters_cooldown(
        &self,
        blocks: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationParametersCooldown", blocks, None, None)
            .await
    }
    pub async fn set_protocol_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setProtocolPercentage", percentage, None, None)
            .await
    }
    pub async fn set_rebate_ratio(
        &self,
        alpha_numerator: u32,
        alpha_denominator: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setRebateRatio",
                (alpha_numerator, alpha_denominator),
                None,
                None,
            )
            .await
    }
    pub async fn stake_to(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("stakeTo", (indexer, tokens), None, None)
            .await
    }
    pub async fn set_asset_holder(
        &self,
        asset_holder: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setAssetHolder", (asset_holder, allowed), None, None)
            .await
    }
    pub async fn set_max_allocation_epochs(
        &self,
        max_allocation_epochs: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setMaxAllocationEpochs", max_allocation_epochs, None, None)
            .await
    }
    pub async fn set_delegation_parameters(
        &self,
        indexing_reward_cut: u32,
        query_fee_cut: u32,
        cooldown_blocks: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setDelegationParameters",
                (indexing_reward_cut, query_fee_cut, cooldown_blocks),
                None,
                None,
            )
            .await
    }
    pub async fn set_operator(
        &self,
        operator: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setOperator", (operator, allowed), None, None)
            .await
    }
    pub async fn set_thawing_period(
        &self,
        thawing_period: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setThawingPeriod", thawing_period, None, None)
            .await
    }
    pub async fn stake(
        &self,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("stake", tokens, None, None).await
    }
    pub async fn set_curation_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setCurationPercentage", percentage, None, None)
            .await
    }
    pub async fn set_delegation_ratio(
        &self,
        delegation_ratio: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationRatio", delegation_ratio, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IStaking<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn is_allocation(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isAllocation", allocation_id).await
    }
    pub async fn get_subgraph_allocated_tokens(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getSubgraphAllocatedTokens", subgraph_deployment_id)
            .await
    }
    pub async fn is_delegator(
        &self,
        indexer: ::web3::types::Address,
        delegator: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("isDelegator", (indexer, delegator))
            .await
    }
    pub async fn get_delegation(
        &self,
        indexer: ::web3::types::Address,
        delegator: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider
            .call("getDelegation", (indexer, delegator))
            .await
    }
    pub async fn get_allocation_state(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<u8, ::web3::Error> {
        self.provider
            .call("getAllocationState", allocation_id)
            .await
    }
    pub async fn has_stake(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("hasStake", indexer).await
    }
    pub async fn get_indexer_capacity(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getIndexerCapacity", indexer).await
    }
    pub async fn get_allocation(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::Address,
            [u8; 32usize],
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("getAllocation", allocation_id).await
    }
    pub async fn get_indexer_staked_tokens(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getIndexerStakedTokens", indexer).await
    }
    pub async fn is_operator(
        &self,
        operator: ::web3::types::Address,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isOperator", (operator, indexer)).await
    }
}
pub struct IGraphProxy<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IGraphProxy<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IGraphProxy<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [],\n    \"name\": \"acceptUpgrade\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptUpgradeAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"admin\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"implementation\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingImplementation\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newAdmin\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setAdmin\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newImplementation\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"upgradeTo\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IGraphProxy<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn upgrade_to(
        &self,
        new_implementation: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("upgradeTo", new_implementation, None, None)
            .await
    }
    pub async fn accept_upgrade(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptUpgrade", (), None, None).await
    }
    pub async fn accept_upgrade_and_call(
        &self,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptUpgradeAndCall", data, None, None)
            .await
    }
    pub async fn implementation(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("implementation", (), None, None).await
    }
    pub async fn admin(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("admin", (), None, None).await
    }
    pub async fn pending_implementation(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("pendingImplementation", (), None, None)
            .await
    }
    pub async fn set_admin(
        &self,
        new_admin: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("setAdmin", new_admin, None, None).await
    }
}
impl<SolidityBindgenProvider> IGraphProxy<SolidityBindgenProvider> where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider
{
}
pub struct IServiceRegistry<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IServiceRegistry<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IServiceRegistry<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isRegistered\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_url\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_geohash\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"register\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_url\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_geohash\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"registerFor\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"unregister\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"unregisterFor\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IServiceRegistry<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn register_for(
        &self,
        indexer: ::web3::types::Address,
        url: ::std::string::String,
        geohash: ::std::string::String,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("registerFor", (indexer, url, geohash), None, None)
            .await
    }
    pub async fn register(
        &self,
        url: ::std::string::String,
        geohash: ::std::string::String,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("register", (url, geohash), None, None)
            .await
    }
    pub async fn unregister(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("unregister", (), None, None).await
    }
    pub async fn unregister_for(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("unregisterFor", indexer, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IServiceRegistry<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn is_registered(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isRegistered", indexer).await
    }
}
pub struct Curation<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for Curation<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> Curation<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"curator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"signal\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Burned\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Collected\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"curator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"signal\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"curationTax\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Signalled\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"acceptProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptProxyAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"bondingCurve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_signalIn\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensOutMin\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burn\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"collect\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"curationTaxPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"defaultReserveRatio\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getCurationPoolSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getCurationPoolTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_curator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getCuratorSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_bondingCurve\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_defaultReserveRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_curationTaxPercentage\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumCurationDeposit\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"isCurated\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"minimumCurationDeposit\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensIn\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_signalOutMin\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"pools\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"reserveRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"contract IGraphCurationToken\",\n        \"name\": \"gcs\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setCurationTaxPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_defaultReserveRatio\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDefaultReserveRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumCurationDeposit\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setMinimumCurationDeposit\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_signalIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"signalToTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"tokensToSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> Curation<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn initialize(
        &self,
        controller: ::web3::types::Address,
        bonding_curve: ::web3::types::Address,
        default_reserve_ratio: u32,
        curation_tax_percentage: u32,
        minimum_curation_deposit: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "initialize",
                (
                    controller,
                    bonding_curve,
                    default_reserve_ratio,
                    curation_tax_percentage,
                    minimum_curation_deposit,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn collect(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("collect", (subgraph_deployment_id, tokens), None, None)
            .await
    }
    pub async fn set_curation_tax_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setCurationTaxPercentage", percentage, None, None)
            .await
    }
    pub async fn accept_proxy_and_call(
        &self,
        proxy: ::web3::types::Address,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptProxyAndCall", (proxy, data), None, None)
            .await
    }
    pub async fn accept_proxy(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptProxy", proxy, None, None).await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
    pub async fn set_default_reserve_ratio(
        &self,
        default_reserve_ratio: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDefaultReserveRatio", default_reserve_ratio, None, None)
            .await
    }
    pub async fn mint(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        tokens_in: ::web3::types::U256,
        signal_out_min: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "mint",
                (subgraph_deployment_id, tokens_in, signal_out_min),
                None,
                None,
            )
            .await
    }
    pub async fn set_minimum_curation_deposit(
        &self,
        minimum_curation_deposit: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setMinimumCurationDeposit",
                minimum_curation_deposit,
                None,
                None,
            )
            .await
    }
    pub async fn burn(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        signal_in: ::web3::types::U256,
        tokens_out_min: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "burn",
                (subgraph_deployment_id, signal_in, tokens_out_min),
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> Curation<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn bonding_curve(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("bondingCurve", ()).await
    }
    pub async fn get_curation_pool_tokens(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getCurationPoolTokens", subgraph_deployment_id)
            .await
    }
    pub async fn is_curated(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("isCurated", subgraph_deployment_id)
            .await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn minimum_curation_deposit(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("minimumCurationDeposit", ()).await
    }
    pub async fn pools(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<(::web3::types::U256, u32, ::web3::types::Address), ::web3::Error>
    {
        self.provider.call("pools", input_0).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn curation_tax_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("curationTaxPercentage", ()).await
    }
    pub async fn default_reserve_ratio(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("defaultReserveRatio", ()).await
    }
    pub async fn signal_to_tokens(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        signal_in: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("signalToTokens", (subgraph_deployment_id, signal_in))
            .await
    }
    pub async fn tokens_to_signal(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        tokens_in: ::web3::types::U256,
    ) -> ::std::result::Result<(::web3::types::U256, ::web3::types::U256), ::web3::Error> {
        self.provider
            .call("tokensToSignal", (subgraph_deployment_id, tokens_in))
            .await
    }
    pub async fn get_curation_pool_signal(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getCurationPoolSignal", subgraph_deployment_id)
            .await
    }
    pub async fn get_curator_signal(
        &self,
        curator: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getCuratorSignal", (curator, subgraph_deployment_id))
            .await
    }
}
pub struct IGNS<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IGNS<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IGNS<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [],\n    \"name\": \"approveAll\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_nSignal\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensOutMin\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burnNSignal\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"deprecateSubgraph\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_curator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getCuratorNSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"isPublished\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensIn\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_nSignalOutMin\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mintNSignal\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_nSignalIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"nSignalToTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_nSignalIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"nSignalToVSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_versionMetadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphMetadata\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"publishNewSubgraph\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_versionMetadata\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"publishNewVersion\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"_nameSystem\",\n        \"type\": \"uint8\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_nameIdentifier\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_name\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"setDefaultName\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_ownerTaxPercentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setOwnerTaxPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"tokensToNSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphMetadata\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"updateSubgraphMetadata\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_vSignalIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"vSignalToNSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IGNS<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_owner_tax_percentage(
        &self,
        owner_tax_percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setOwnerTaxPercentage", owner_tax_percentage, None, None)
            .await
    }
    pub async fn deprecate_subgraph(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "deprecateSubgraph",
                (graph_account, subgraph_number),
                None,
                None,
            )
            .await
    }
    pub async fn mint_n_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        tokens_in: ::web3::types::U256,
        n_signal_out_min: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "mintNSignal",
                (graph_account, subgraph_number, tokens_in, n_signal_out_min),
                None,
                None,
            )
            .await
    }
    pub async fn publish_new_subgraph(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
        version_metadata: [u8; 32usize],
        subgraph_metadata: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "publishNewSubgraph",
                (
                    graph_account,
                    subgraph_deployment_id,
                    version_metadata,
                    subgraph_metadata,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn set_default_name(
        &self,
        graph_account: ::web3::types::Address,
        name_system: u8,
        name_identifier: [u8; 32usize],
        name: ::std::string::String,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setDefaultName",
                (graph_account, name_system, name_identifier, name),
                None,
                None,
            )
            .await
    }
    pub async fn withdraw(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("withdraw", (graph_account, subgraph_number), None, None)
            .await
    }
    pub async fn approve_all(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("approveAll", (), None, None).await
    }
    pub async fn update_subgraph_metadata(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        subgraph_metadata: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "updateSubgraphMetadata",
                (graph_account, subgraph_number, subgraph_metadata),
                None,
                None,
            )
            .await
    }
    pub async fn publish_new_version(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        subgraph_deployment_id: [u8; 32usize],
        version_metadata: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "publishNewVersion",
                (
                    graph_account,
                    subgraph_number,
                    subgraph_deployment_id,
                    version_metadata,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn burn_n_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        n_signal: ::web3::types::U256,
        tokens_out_min: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "burnNSignal",
                (graph_account, subgraph_number, n_signal, tokens_out_min),
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> IGNS<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn tokens_to_n_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        tokens_in: ::web3::types::U256,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider
            .call(
                "tokensToNSignal",
                (graph_account, subgraph_number, tokens_in),
            )
            .await
    }
    pub async fn n_signal_to_tokens(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        n_signal_in: ::web3::types::U256,
    ) -> ::std::result::Result<(::web3::types::U256, ::web3::types::U256), ::web3::Error> {
        self.provider
            .call(
                "nSignalToTokens",
                (graph_account, subgraph_number, n_signal_in),
            )
            .await
    }
    pub async fn is_published(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("isPublished", (graph_account, subgraph_number))
            .await
    }
    pub async fn v_signal_to_n_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        v_signal_in: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "vSignalToNSignal",
                (graph_account, subgraph_number, v_signal_in),
            )
            .await
    }
    pub async fn get_curator_n_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        curator: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "getCuratorNSignal",
                (graph_account, subgraph_number, curator),
            )
            .await
    }
    pub async fn n_signal_to_v_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        n_signal_in: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "nSignalToVSignal",
                (graph_account, subgraph_number, n_signal_in),
            )
            .await
    }
}
pub struct Managed<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for Managed<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> Managed<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> Managed<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> Managed<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
}
pub struct ERC20Burnable<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for ERC20Burnable<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> ERC20Burnable<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burn\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burnFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"subtractedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"decreaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"addedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"increaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> ERC20Burnable<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn transfer_from(
        &self,
        sender: ::web3::types::Address,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferFrom", (sender, recipient, amount), None, None)
            .await
    }
    pub async fn burn_from(
        &self,
        account: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("burnFrom", (account, amount), None, None)
            .await
    }
    pub async fn increase_allowance(
        &self,
        spender: ::web3::types::Address,
        added_value: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("increaseAllowance", (spender, added_value), None, None)
            .await
    }
    pub async fn approve(
        &self,
        spender: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("approve", (spender, amount), None, None)
            .await
    }
    pub async fn transfer(
        &self,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transfer", (recipient, amount), None, None)
            .await
    }
    pub async fn burn(
        &self,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("burn", amount, None, None).await
    }
    pub async fn decrease_allowance(
        &self,
        spender: ::web3::types::Address,
        subtracted_value: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("decreaseAllowance", (spender, subtracted_value), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> ERC20Burnable<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn name(&self) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("name", ()).await
    }
    pub async fn allowance(
        &self,
        owner: ::web3::types::Address,
        spender: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("allowance", (owner, spender)).await
    }
    pub async fn decimals(&self) -> ::std::result::Result<u8, ::web3::Error> {
        self.provider.call("decimals", ()).await
    }
    pub async fn symbol(&self) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("symbol", ()).await
    }
    pub async fn balance_of(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("balanceOf", account).await
    }
    pub async fn total_supply(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("totalSupply", ()).await
    }
}
pub struct IStakingV1<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IStakingV1<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IStakingV1<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"allocate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"allocateFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_restake\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"claim\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address[]\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address[]\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_restake\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"claimMany\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_poi\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"closeAllocation\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"address\",\n            \"name\": \"allocationID\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"poi\",\n            \"type\": \"bytes32\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.CloseAllocationRequest[]\",\n        \"name\": \"_requests\",\n        \"type\": \"tuple[]\"\n      }\n    ],\n    \"name\": \"closeAllocationMany\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_oldAllocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_poi\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"closeAndAllocate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"collect\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"delegate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getAllocation\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"address\",\n            \"name\": \"indexer\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokens\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"createdAtEpoch\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"closedAtEpoch\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"collectedFees\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"effectiveAllocation\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"accRewardsPerAllocatedToken\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.Allocation\",\n        \"name\": \"\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getAllocationState\",\n    \"outputs\": [\n      {\n        \"internalType\": \"enum IStakingV1.AllocationState\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_delegator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getDelegation\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"shares\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLocked\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLockedUntil\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.Delegation\",\n        \"name\": \"\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getIndexerCapacity\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getIndexerStakedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getSubgraphAllocatedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"hasStake\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isAllocation\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_delegator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isDelegator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isOperator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_assetHolder\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setAssetHolder\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_channelDisputeEpochs\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setChannelDisputeEpochs\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setCurationPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_indexingRewardCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_queryFeeCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_cooldownBlocks\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationParameters\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_blocks\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationParametersCooldown\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationRatio\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationTaxPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationUnbondingPeriod\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationUnbondingPeriod\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_maxAllocationEpochs\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setMaxAllocationEpochs\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumIndexerStake\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setMinimumIndexerStake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setOperator\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setProtocolPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setRebateRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_slasher\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setSlasher\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_thawingPeriod\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setThawingPeriod\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_reward\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_beneficiary\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"slash\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"stake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"stakeTo\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"undelegate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"unstake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newIndexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"withdrawDelegated\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IStakingV1<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_minimum_indexer_stake(
        &self,
        minimum_indexer_stake: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setMinimumIndexerStake", minimum_indexer_stake, None, None)
            .await
    }
    pub async fn set_delegation_parameters(
        &self,
        indexing_reward_cut: u32,
        query_fee_cut: u32,
        cooldown_blocks: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setDelegationParameters",
                (indexing_reward_cut, query_fee_cut, cooldown_blocks),
                None,
                None,
            )
            .await
    }
    pub async fn claim(
        &self,
        allocation_id: ::web3::types::Address,
        restake: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("claim", (allocation_id, restake), None, None)
            .await
    }
    pub async fn set_delegation_parameters_cooldown(
        &self,
        blocks: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationParametersCooldown", blocks, None, None)
            .await
    }
    pub async fn stake_to(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("stakeTo", (indexer, tokens), None, None)
            .await
    }
    pub async fn allocate(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "allocate",
                (
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn close_and_allocate(
        &self,
        old_allocation_id: ::web3::types::Address,
        poi: [u8; 32usize],
        indexer: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "closeAndAllocate",
                (
                    old_allocation_id,
                    poi,
                    indexer,
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn close_allocation_many(
        &self,
        requests: ::solidity_bindgen::internal::Unimplemented,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("closeAllocationMany", requests, None, None)
            .await
    }
    pub async fn set_channel_dispute_epochs(
        &self,
        channel_dispute_epochs: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setChannelDisputeEpochs",
                channel_dispute_epochs,
                None,
                None,
            )
            .await
    }
    pub async fn withdraw(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("withdraw", (), None, None).await
    }
    pub async fn withdraw_delegated(
        &self,
        indexer: ::web3::types::Address,
        new_indexer: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("withdrawDelegated", (indexer, new_indexer), None, None)
            .await
    }
    pub async fn set_delegation_unbonding_period(
        &self,
        delegation_unbonding_period: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setDelegationUnbondingPeriod",
                delegation_unbonding_period,
                None,
                None,
            )
            .await
    }
    pub async fn close_allocation(
        &self,
        allocation_id: ::web3::types::Address,
        poi: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("closeAllocation", (allocation_id, poi), None, None)
            .await
    }
    pub async fn set_slasher(
        &self,
        slasher: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setSlasher", (slasher, allowed), None, None)
            .await
    }
    pub async fn set_delegation_ratio(
        &self,
        delegation_ratio: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationRatio", delegation_ratio, None, None)
            .await
    }
    pub async fn set_max_allocation_epochs(
        &self,
        max_allocation_epochs: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setMaxAllocationEpochs", max_allocation_epochs, None, None)
            .await
    }
    pub async fn allocate_from(
        &self,
        indexer: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "allocateFrom",
                (
                    indexer,
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn set_operator(
        &self,
        operator: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setOperator", (operator, allowed), None, None)
            .await
    }
    pub async fn set_protocol_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setProtocolPercentage", percentage, None, None)
            .await
    }
    pub async fn set_delegation_tax_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationTaxPercentage", percentage, None, None)
            .await
    }
    pub async fn claim_many(
        &self,
        allocation_id: ::std::vec::Vec<::web3::types::Address>,
        restake: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("claimMany", (allocation_id, restake), None, None)
            .await
    }
    pub async fn delegate(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("delegate", (indexer, tokens), None, None)
            .await
    }
    pub async fn collect(
        &self,
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("collect", (tokens, allocation_id), None, None)
            .await
    }
    pub async fn unstake(
        &self,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("unstake", tokens, None, None).await
    }
    pub async fn set_rebate_ratio(
        &self,
        alpha_numerator: u32,
        alpha_denominator: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setRebateRatio",
                (alpha_numerator, alpha_denominator),
                None,
                None,
            )
            .await
    }
    pub async fn set_asset_holder(
        &self,
        asset_holder: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setAssetHolder", (asset_holder, allowed), None, None)
            .await
    }
    pub async fn set_thawing_period(
        &self,
        thawing_period: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setThawingPeriod", thawing_period, None, None)
            .await
    }
    pub async fn slash(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
        reward: ::web3::types::U256,
        beneficiary: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("slash", (indexer, tokens, reward, beneficiary), None, None)
            .await
    }
    pub async fn set_curation_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setCurationPercentage", percentage, None, None)
            .await
    }
    pub async fn stake(
        &self,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("stake", tokens, None, None).await
    }
    pub async fn undelegate(
        &self,
        indexer: ::web3::types::Address,
        shares: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("undelegate", (indexer, shares), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IStakingV1<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn get_subgraph_allocated_tokens(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getSubgraphAllocatedTokens", subgraph_deployment_id)
            .await
    }
    pub async fn has_stake(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("hasStake", indexer).await
    }
    pub async fn get_allocation_state(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<u8, ::web3::Error> {
        self.provider
            .call("getAllocationState", allocation_id)
            .await
    }
    pub async fn is_operator(
        &self,
        operator: ::web3::types::Address,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isOperator", (operator, indexer)).await
    }
    pub async fn get_delegation(
        &self,
        indexer: ::web3::types::Address,
        delegator: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider
            .call("getDelegation", (indexer, delegator))
            .await
    }
    pub async fn get_indexer_staked_tokens(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getIndexerStakedTokens", indexer).await
    }
    pub async fn get_indexer_capacity(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getIndexerCapacity", indexer).await
    }
    pub async fn is_allocation(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isAllocation", allocation_id).await
    }
    pub async fn is_delegator(
        &self,
        indexer: ::web3::types::Address,
        delegator: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("isDelegator", (indexer, delegator))
            .await
    }
    pub async fn get_allocation(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::Address,
            [u8; 32usize],
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("getAllocation", allocation_id).await
    }
}
pub struct ICuration<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for ICuration<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> ICuration<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_signalIn\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensOutMin\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burn\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"collect\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"curationTaxPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getCurationPoolSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getCurationPoolTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_curator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getCuratorSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"isCurated\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensIn\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_signalOutMin\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setCurationTaxPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_defaultReserveRatio\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDefaultReserveRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumCurationDeposit\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setMinimumCurationDeposit\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_signalIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"signalToTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"tokensToSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> ICuration<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn burn(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        signal_in: ::web3::types::U256,
        tokens_out_min: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "burn",
                (subgraph_deployment_id, signal_in, tokens_out_min),
                None,
                None,
            )
            .await
    }
    pub async fn set_default_reserve_ratio(
        &self,
        default_reserve_ratio: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDefaultReserveRatio", default_reserve_ratio, None, None)
            .await
    }
    pub async fn set_minimum_curation_deposit(
        &self,
        minimum_curation_deposit: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setMinimumCurationDeposit",
                minimum_curation_deposit,
                None,
                None,
            )
            .await
    }
    pub async fn mint(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        tokens_in: ::web3::types::U256,
        signal_out_min: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "mint",
                (subgraph_deployment_id, tokens_in, signal_out_min),
                None,
                None,
            )
            .await
    }
    pub async fn set_curation_tax_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setCurationTaxPercentage", percentage, None, None)
            .await
    }
    pub async fn collect(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("collect", (subgraph_deployment_id, tokens), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> ICuration<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn get_curation_pool_signal(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getCurationPoolSignal", subgraph_deployment_id)
            .await
    }
    pub async fn get_curation_pool_tokens(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getCurationPoolTokens", subgraph_deployment_id)
            .await
    }
    pub async fn is_curated(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("isCurated", subgraph_deployment_id)
            .await
    }
    pub async fn curation_tax_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("curationTaxPercentage", ()).await
    }
    pub async fn tokens_to_signal(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        tokens_in: ::web3::types::U256,
    ) -> ::std::result::Result<(::web3::types::U256, ::web3::types::U256), ::web3::Error> {
        self.provider
            .call("tokensToSignal", (subgraph_deployment_id, tokens_in))
            .await
    }
    pub async fn get_curator_signal(
        &self,
        curator: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getCuratorSignal", (curator, subgraph_deployment_id))
            .await
    }
    pub async fn signal_to_tokens(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        signal_in: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("signalToTokens", (subgraph_deployment_id, signal_in))
            .await
    }
}
pub struct GDAI<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GDAI<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GDAI<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewPendingOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"GSR\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"acceptOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burn\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burnFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"subtractedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"decreaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"governor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"addedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"increaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingGovernor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_GSR\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setGSR\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newGovernor\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GDAI<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_gsr(
        &self,
        gsr: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("setGSR", gsr, None, None).await
    }
    pub async fn transfer_ownership(
        &self,
        new_governor: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferOwnership", new_governor, None, None)
            .await
    }
    pub async fn burn(
        &self,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("burn", amount, None, None).await
    }
    pub async fn transfer(
        &self,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transfer", (recipient, amount), None, None)
            .await
    }
    pub async fn burn_from(
        &self,
        account: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("burnFrom", (account, amount), None, None)
            .await
    }
    pub async fn approve(
        &self,
        spender: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("approve", (spender, amount), None, None)
            .await
    }
    pub async fn decrease_allowance(
        &self,
        spender: ::web3::types::Address,
        subtracted_value: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("decreaseAllowance", (spender, subtracted_value), None, None)
            .await
    }
    pub async fn mint(
        &self,
        to: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("mint", (to, amount), None, None).await
    }
    pub async fn transfer_from(
        &self,
        sender: ::web3::types::Address,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferFrom", (sender, recipient, amount), None, None)
            .await
    }
    pub async fn increase_allowance(
        &self,
        spender: ::web3::types::Address,
        added_value: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("increaseAllowance", (spender, added_value), None, None)
            .await
    }
    pub async fn accept_ownership(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptOwnership", (), None, None).await
    }
}
impl<SolidityBindgenProvider> GDAI<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn gsr(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("GSR", ()).await
    }
    pub async fn name(&self) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("name", ()).await
    }
    pub async fn allowance(
        &self,
        owner: ::web3::types::Address,
        spender: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("allowance", (owner, spender)).await
    }
    pub async fn decimals(&self) -> ::std::result::Result<u8, ::web3::Error> {
        self.provider.call("decimals", ()).await
    }
    pub async fn governor(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("governor", ()).await
    }
    pub async fn symbol(&self) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("symbol", ()).await
    }
    pub async fn balance_of(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("balanceOf", account).await
    }
    pub async fn total_supply(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("totalSupply", ()).await
    }
    pub async fn pending_governor(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("pendingGovernor", ()).await
    }
}
pub struct IPublicResolver<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IPublicResolver<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IPublicResolver<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"node\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"key\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"value\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"setText\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"node\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"key\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"text\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IPublicResolver<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_text(
        &self,
        node: [u8; 32usize],
        key: ::std::string::String,
        value: ::std::string::String,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setText", (node, key, value), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IPublicResolver<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn text(
        &self,
        node: [u8; 32usize],
        key: ::std::string::String,
    ) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("text", (node, key)).await
    }
}
pub struct ServiceRegistryV1Storage<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone
    for ServiceRegistryV1Storage<SolidityBindgenProvider>
{
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> ServiceRegistryV1Storage<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"services\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"url\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"geohash\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> ServiceRegistryV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> ServiceRegistryV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn services(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<(::std::string::String, ::std::string::String), ::web3::Error> {
        self.provider.call("services", input_0).await
    }
}
pub struct IGraphCurationToken<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IGraphCurationToken<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IGraphCurationToken<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_account\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burnFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IGraphCurationToken<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn transfer(
        &self,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transfer", (recipient, amount), None, None)
            .await
    }
    pub async fn approve(
        &self,
        spender: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("approve", (spender, amount), None, None)
            .await
    }
    pub async fn burn_from(
        &self,
        account: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("burnFrom", (account, amount), None, None)
            .await
    }
    pub async fn mint(
        &self,
        to: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("mint", (to, amount), None, None).await
    }
    pub async fn transfer_from(
        &self,
        sender: ::web3::types::Address,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferFrom", (sender, recipient, amount), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IGraphCurationToken<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn allowance(
        &self,
        owner: ::web3::types::Address,
        spender: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("allowance", (owner, spender)).await
    }
    pub async fn balance_of(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("balanceOf", account).await
    }
    pub async fn total_supply(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("totalSupply", ()).await
    }
}
pub struct DisputeManager<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for DisputeManager<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> DisputeManager<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"disputeID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"fisherman\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"DisputeAccepted\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"disputeID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"fisherman\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"DisputeDrawn\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"disputeID1\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"disputeID2\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"DisputeLinked\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"disputeID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"fisherman\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"DisputeRejected\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"disputeID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"fisherman\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"IndexingDisputeCreated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"disputeID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"fisherman\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes\",\n        \"name\": \"attestation\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"QueryDisputeCreated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_disputeID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"acceptDispute\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"acceptProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptProxyAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"arbitrator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"requestCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"responseCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"r\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"s\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"uint8\",\n            \"name\": \"v\",\n            \"type\": \"uint8\"\n          }\n        ],\n        \"internalType\": \"struct IDisputeManager.Attestation\",\n        \"name\": \"_attestation1\",\n        \"type\": \"tuple\"\n      },\n      {\n        \"components\": [\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"requestCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"responseCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"r\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"s\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"uint8\",\n            \"name\": \"v\",\n            \"type\": \"uint8\"\n          }\n        ],\n        \"internalType\": \"struct IDisputeManager.Attestation\",\n        \"name\": \"_attestation2\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"name\": \"areConflictingAttestations\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"pure\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_deposit\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"createIndexingDispute\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_attestationData\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_deposit\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"createQueryDispute\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_attestationData1\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_attestationData2\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"createQueryDisputeConflict\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"disputes\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"fisherman\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"deposit\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"relatedDisputeID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_disputeID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"drawDispute\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"requestCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"responseCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          }\n        ],\n        \"internalType\": \"struct IDisputeManager.Receipt\",\n        \"name\": \"_receipt\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"name\": \"encodeHashReceipt\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"fishermanRewardPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"requestCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"responseCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"r\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"s\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"uint8\",\n            \"name\": \"v\",\n            \"type\": \"uint8\"\n          }\n        ],\n        \"internalType\": \"struct IDisputeManager.Attestation\",\n        \"name\": \"_attestation\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"name\": \"getAttestationIndexer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getTokensToReward\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getTokensToSlash\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_arbitrator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumDeposit\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_fishermanRewardPercentage\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_slashingPercentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_disputeID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"isDisputeCreated\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"minimumDeposit\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_disputeID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"rejectDispute\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_arbitrator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setArbitrator\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setFishermanRewardPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumDeposit\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setMinimumDeposit\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setSlashingPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"slashingPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> DisputeManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn create_query_dispute(
        &self,
        attestation_data: ::std::vec::Vec<u8>,
        deposit: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "createQueryDispute",
                (attestation_data, deposit),
                None,
                None,
            )
            .await
    }
    pub async fn accept_proxy(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptProxy", proxy, None, None).await
    }
    pub async fn create_indexing_dispute(
        &self,
        allocation_id: ::web3::types::Address,
        deposit: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "createIndexingDispute",
                (allocation_id, deposit),
                None,
                None,
            )
            .await
    }
    pub async fn draw_dispute(
        &self,
        dispute_id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("drawDispute", dispute_id, None, None)
            .await
    }
    pub async fn set_fisherman_reward_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setFishermanRewardPercentage", percentage, None, None)
            .await
    }
    pub async fn reject_dispute(
        &self,
        dispute_id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("rejectDispute", dispute_id, None, None)
            .await
    }
    pub async fn initialize(
        &self,
        controller: ::web3::types::Address,
        arbitrator: ::web3::types::Address,
        minimum_deposit: ::web3::types::U256,
        fisherman_reward_percentage: u32,
        slashing_percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "initialize",
                (
                    controller,
                    arbitrator,
                    minimum_deposit,
                    fisherman_reward_percentage,
                    slashing_percentage,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn accept_proxy_and_call(
        &self,
        proxy: ::web3::types::Address,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptProxyAndCall", (proxy, data), None, None)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
    pub async fn set_minimum_deposit(
        &self,
        minimum_deposit: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setMinimumDeposit", minimum_deposit, None, None)
            .await
    }
    pub async fn set_slashing_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setSlashingPercentage", percentage, None, None)
            .await
    }
    pub async fn set_arbitrator(
        &self,
        arbitrator: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setArbitrator", arbitrator, None, None)
            .await
    }
    pub async fn accept_dispute(
        &self,
        dispute_id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptDispute", dispute_id, None, None)
            .await
    }
    pub async fn create_query_dispute_conflict(
        &self,
        attestation_data_1: ::std::vec::Vec<u8>,
        attestation_data_2: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "createQueryDisputeConflict",
                (attestation_data_1, attestation_data_2),
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> DisputeManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn arbitrator(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("arbitrator", ()).await
    }
    pub async fn get_tokens_to_reward(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getTokensToReward", indexer).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn get_tokens_to_slash(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getTokensToSlash", indexer).await
    }
    pub async fn is_dispute_created(
        &self,
        dispute_id: [u8; 32usize],
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isDisputeCreated", dispute_id).await
    }
    pub async fn minimum_deposit(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("minimumDeposit", ()).await
    }
    pub async fn get_attestation_indexer(
        &self,
        attestation: (
            [u8; 32usize],
            [u8; 32usize],
            [u8; 32usize],
            [u8; 32usize],
            [u8; 32usize],
            u8,
        ),
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider
            .call("getAttestationIndexer", attestation)
            .await
    }
    pub async fn slashing_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("slashingPercentage", ()).await
    }
    pub async fn disputes(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<
        (
            ::web3::types::Address,
            ::web3::types::Address,
            ::web3::types::U256,
            [u8; 32usize],
        ),
        ::web3::Error,
    > {
        self.provider.call("disputes", input_0).await
    }
    pub async fn encode_hash_receipt(
        &self,
        receipt: ([u8; 32usize], [u8; 32usize], [u8; 32usize]),
    ) -> ::std::result::Result<[u8; 32usize], ::web3::Error> {
        self.provider.call("encodeHashReceipt", receipt).await
    }
    pub async fn are_conflicting_attestations(
        &self,
        attestation_1: ::solidity_bindgen::internal::Unimplemented,
        attestation_2: ::solidity_bindgen::internal::Unimplemented,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("areConflictingAttestations", (attestation_1, attestation_2))
            .await
    }
    pub async fn fisherman_reward_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("fishermanRewardPercentage", ()).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
}
pub struct CurationV1Storage<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for CurationV1Storage<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> CurationV1Storage<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"bondingCurve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"defaultReserveRatio\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"minimumCurationDeposit\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"pools\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"reserveRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"contract IGraphCurationToken\",\n        \"name\": \"gcs\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> CurationV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> CurationV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn minimum_curation_deposit(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("minimumCurationDeposit", ()).await
    }
    pub async fn pools(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<(::web3::types::U256, u32, ::web3::types::Address), ::web3::Error>
    {
        self.provider.call("pools", input_0).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn bonding_curve(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("bondingCurve", ()).await
    }
    pub async fn default_reserve_ratio(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("defaultReserveRatio", ()).await
    }
}
pub struct IGraphToken<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IGraphToken<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IGraphToken<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"addMinter\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burn\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isMinter\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_deadline\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"_v\",\n        \"type\": \"uint8\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_r\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_s\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"permit\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"removeMinter\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"renounceMinter\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IGraphToken<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn add_minter(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("addMinter", account, None, None).await
    }
    pub async fn transfer(
        &self,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transfer", (recipient, amount), None, None)
            .await
    }
    pub async fn transfer_from(
        &self,
        sender: ::web3::types::Address,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferFrom", (sender, recipient, amount), None, None)
            .await
    }
    pub async fn mint(
        &self,
        to: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("mint", (to, amount), None, None).await
    }
    pub async fn burn(
        &self,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("burn", amount, None, None).await
    }
    pub async fn remove_minter(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("removeMinter", account, None, None)
            .await
    }
    pub async fn renounce_minter(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("renounceMinter", (), None, None).await
    }
    pub async fn approve(
        &self,
        spender: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("approve", (spender, amount), None, None)
            .await
    }
    pub async fn permit(
        &self,
        owner: ::web3::types::Address,
        spender: ::web3::types::Address,
        value: ::web3::types::U256,
        deadline: ::web3::types::U256,
        v: u8,
        r: [u8; 32usize],
        s: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "permit",
                (owner, spender, value, deadline, v, r, s),
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> IGraphToken<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn balance_of(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("balanceOf", account).await
    }
    pub async fn is_minter(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isMinter", account).await
    }
    pub async fn allowance(
        &self,
        owner: ::web3::types::Address,
        spender: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("allowance", (owner, spender)).await
    }
    pub async fn total_supply(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("totalSupply", ()).await
    }
}
pub struct Controller<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for Controller<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> Controller<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"oldPauseGuardian\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"pauseGuardian\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewPauseGuardian\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewPendingOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"isPaused\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"PartialPauseChanged\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"isPaused\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"PauseChanged\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"id\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"contractAddress\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetContractProxy\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"acceptOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_id\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getContractProxy\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"getGovernor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"governor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastPausePartialTime\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastPauseTime\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"partialPaused\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pauseGuardian\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"paused\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingGovernor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_id\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_contractAddress\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setContractProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_partialPaused\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setPartialPaused\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newPauseGuardian\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setPauseGuardian\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_paused\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setPaused\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newGovernor\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_id\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"unsetContractProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_id\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"updateController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> Controller<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_pause_guardian(
        &self,
        new_pause_guardian: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setPauseGuardian", new_pause_guardian, None, None)
            .await
    }
    pub async fn set_contract_proxy(
        &self,
        id: [u8; 32usize],
        contract_address: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setContractProxy", (id, contract_address), None, None)
            .await
    }
    pub async fn set_paused(
        &self,
        paused: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("setPaused", paused, None, None).await
    }
    pub async fn set_partial_paused(
        &self,
        partial_paused: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setPartialPaused", partial_paused, None, None)
            .await
    }
    pub async fn update_controller(
        &self,
        id: [u8; 32usize],
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("updateController", (id, controller), None, None)
            .await
    }
    pub async fn accept_ownership(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptOwnership", (), None, None).await
    }
    pub async fn transfer_ownership(
        &self,
        new_governor: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferOwnership", new_governor, None, None)
            .await
    }
    pub async fn unset_contract_proxy(
        &self,
        id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("unsetContractProxy", id, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> Controller<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn last_pause_partial_time(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastPausePartialTime", ()).await
    }
    pub async fn partial_paused(&self) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("partialPaused", ()).await
    }
    pub async fn get_contract_proxy(
        &self,
        id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("getContractProxy", id).await
    }
    pub async fn last_pause_time(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastPauseTime", ()).await
    }
    pub async fn paused(&self) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("paused", ()).await
    }
    pub async fn get_governor(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("getGovernor", ()).await
    }
    pub async fn pending_governor(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("pendingGovernor", ()).await
    }
    pub async fn pause_guardian(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("pauseGuardian", ()).await
    }
    pub async fn governor(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("governor", ()).await
    }
}
pub struct DisputeManagerV1Storage<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone
    for DisputeManagerV1Storage<SolidityBindgenProvider>
{
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> DisputeManagerV1Storage<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"arbitrator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"disputes\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"fisherman\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"deposit\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"relatedDisputeID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"fishermanRewardPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"minimumDeposit\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"slashingPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> DisputeManagerV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> DisputeManagerV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn disputes(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<
        (
            ::web3::types::Address,
            ::web3::types::Address,
            ::web3::types::U256,
            [u8; 32usize],
        ),
        ::web3::Error,
    > {
        self.provider.call("disputes", input_0).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn arbitrator(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("arbitrator", ()).await
    }
    pub async fn minimum_deposit(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("minimumDeposit", ()).await
    }
    pub async fn slashing_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("slashingPercentage", ()).await
    }
    pub async fn fisherman_reward_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("fishermanRewardPercentage", ()).await
    }
}
pub struct GraphProxy<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GraphProxy<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GraphProxy<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_impl\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_admin\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"oldAdmin\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"newAdmin\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"AdminUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"oldImplementation\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"newImplementation\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"ImplementationUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"oldPendingImplementation\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"newPendingImplementation\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"PendingImplementationUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"stateMutability\": \"payable\",\n    \"type\": \"fallback\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"acceptUpgrade\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptUpgradeAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"admin\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"implementation\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingImplementation\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newAdmin\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setAdmin\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newImplementation\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"upgradeTo\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"stateMutability\": \"payable\",\n    \"type\": \"receive\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GraphProxy<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn pending_implementation(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("pendingImplementation", (), None, None)
            .await
    }
    pub async fn admin(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("admin", (), None, None).await
    }
    pub async fn accept_upgrade(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptUpgrade", (), None, None).await
    }
    pub async fn upgrade_to(
        &self,
        new_implementation: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("upgradeTo", new_implementation, None, None)
            .await
    }
    pub async fn set_admin(
        &self,
        new_admin: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("setAdmin", new_admin, None, None).await
    }
    pub async fn accept_upgrade_and_call(
        &self,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptUpgradeAndCall", data, None, None)
            .await
    }
    pub async fn implementation(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("implementation", (), None, None).await
    }
}
impl<SolidityBindgenProvider> GraphProxy<SolidityBindgenProvider> where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider
{
}
pub struct IDisputeManager<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IDisputeManager<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IDisputeManager<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_disputeID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"acceptDispute\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"requestCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"responseCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"r\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"s\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"uint8\",\n            \"name\": \"v\",\n            \"type\": \"uint8\"\n          }\n        ],\n        \"internalType\": \"struct IDisputeManager.Attestation\",\n        \"name\": \"_attestation1\",\n        \"type\": \"tuple\"\n      },\n      {\n        \"components\": [\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"requestCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"responseCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"r\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"s\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"uint8\",\n            \"name\": \"v\",\n            \"type\": \"uint8\"\n          }\n        ],\n        \"internalType\": \"struct IDisputeManager.Attestation\",\n        \"name\": \"_attestation2\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"name\": \"areConflictingAttestations\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"pure\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_deposit\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"createIndexingDispute\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_attestationData\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_deposit\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"createQueryDispute\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_attestationData1\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_attestationData2\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"createQueryDisputeConflict\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_disputeID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"drawDispute\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"requestCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"responseCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          }\n        ],\n        \"internalType\": \"struct IDisputeManager.Receipt\",\n        \"name\": \"_receipt\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"name\": \"encodeHashReceipt\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"requestCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"responseCID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"r\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"s\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"uint8\",\n            \"name\": \"v\",\n            \"type\": \"uint8\"\n          }\n        ],\n        \"internalType\": \"struct IDisputeManager.Attestation\",\n        \"name\": \"_attestation\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"name\": \"getAttestationIndexer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getTokensToReward\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getTokensToSlash\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_disputeID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"isDisputeCreated\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_disputeID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"rejectDispute\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_arbitrator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setArbitrator\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setFishermanRewardPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumDeposit\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setMinimumDeposit\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setSlashingPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IDisputeManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_slashing_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setSlashingPercentage", percentage, None, None)
            .await
    }
    pub async fn create_query_dispute(
        &self,
        attestation_data: ::std::vec::Vec<u8>,
        deposit: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "createQueryDispute",
                (attestation_data, deposit),
                None,
                None,
            )
            .await
    }
    pub async fn set_arbitrator(
        &self,
        arbitrator: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setArbitrator", arbitrator, None, None)
            .await
    }
    pub async fn set_fisherman_reward_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setFishermanRewardPercentage", percentage, None, None)
            .await
    }
    pub async fn accept_dispute(
        &self,
        dispute_id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptDispute", dispute_id, None, None)
            .await
    }
    pub async fn create_indexing_dispute(
        &self,
        allocation_id: ::web3::types::Address,
        deposit: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "createIndexingDispute",
                (allocation_id, deposit),
                None,
                None,
            )
            .await
    }
    pub async fn reject_dispute(
        &self,
        dispute_id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("rejectDispute", dispute_id, None, None)
            .await
    }
    pub async fn create_query_dispute_conflict(
        &self,
        attestation_data_1: ::std::vec::Vec<u8>,
        attestation_data_2: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "createQueryDisputeConflict",
                (attestation_data_1, attestation_data_2),
                None,
                None,
            )
            .await
    }
    pub async fn set_minimum_deposit(
        &self,
        minimum_deposit: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setMinimumDeposit", minimum_deposit, None, None)
            .await
    }
    pub async fn draw_dispute(
        &self,
        dispute_id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("drawDispute", dispute_id, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IDisputeManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn get_tokens_to_reward(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getTokensToReward", indexer).await
    }
    pub async fn is_dispute_created(
        &self,
        dispute_id: [u8; 32usize],
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isDisputeCreated", dispute_id).await
    }
    pub async fn get_tokens_to_slash(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getTokensToSlash", indexer).await
    }
    pub async fn get_attestation_indexer(
        &self,
        attestation: (
            [u8; 32usize],
            [u8; 32usize],
            [u8; 32usize],
            [u8; 32usize],
            [u8; 32usize],
            u8,
        ),
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider
            .call("getAttestationIndexer", attestation)
            .await
    }
    pub async fn are_conflicting_attestations(
        &self,
        attestation_1: ::solidity_bindgen::internal::Unimplemented,
        attestation_2: ::solidity_bindgen::internal::Unimplemented,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("areConflictingAttestations", (attestation_1, attestation_2))
            .await
    }
    pub async fn encode_hash_receipt(
        &self,
        receipt: ([u8; 32usize], [u8; 32usize], [u8; 32usize]),
    ) -> ::std::result::Result<[u8; 32usize], ::web3::Error> {
        self.provider.call("encodeHashReceipt", receipt).await
    }
}
pub struct GSRManager<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GSRManager<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GSRManager<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_savingsRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_gdai\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"cumulativeInterestRate\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"lastDripTime\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Drip\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"gsrBalance\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"gdai\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Exit\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"gdai\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"gsrBalance\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Join\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewPendingOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"newRate\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"SetRate\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"acceptOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balances\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"calcReturn\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalBalance\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"calcUpdatedRate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"updatedRate\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"cumulativeInterestRate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"drip\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"updatedRate\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"exit\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"governor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"join\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastDripTime\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingGovernor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"reserves\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"savingsRate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_newRate\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setRate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"token\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract GDAI\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newGovernor\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GSRManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn transfer_ownership(
        &self,
        new_governor: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferOwnership", new_governor, None, None)
            .await
    }
    pub async fn join(
        &self,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("join", amount, None, None).await
    }
    pub async fn exit(
        &self,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("exit", amount, None, None).await
    }
    pub async fn set_rate(
        &self,
        new_rate: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("setRate", new_rate, None, None).await
    }
    pub async fn drip(&self) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("drip", (), None, None).await
    }
    pub async fn accept_ownership(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptOwnership", (), None, None).await
    }
}
impl<SolidityBindgenProvider> GSRManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn reserves(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("reserves", ()).await
    }
    pub async fn cumulative_interest_rate(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("cumulativeInterestRate", ()).await
    }
    pub async fn governor(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("governor", ()).await
    }
    pub async fn balances(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("balances", input_0).await
    }
    pub async fn calc_updated_rate(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("calcUpdatedRate", ()).await
    }
    pub async fn token(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("token", ()).await
    }
    pub async fn pending_governor(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("pendingGovernor", ()).await
    }
    pub async fn savings_rate(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("savingsRate", ()).await
    }
    pub async fn calc_return(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("calcReturn", account).await
    }
    pub async fn last_drip_time(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastDripTime", ()).await
    }
}
pub struct ITestRegistrar<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for ITestRegistrar<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> ITestRegistrar<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"label\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"register\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> ITestRegistrar<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn register(
        &self,
        label: [u8; 32usize],
        owner: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("register", (label, owner), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> ITestRegistrar<SolidityBindgenProvider> where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider
{
}
pub struct EpochManagerV1Storage<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone
    for EpochManagerV1Storage<SolidityBindgenProvider>
{
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> EpochManagerV1Storage<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"epochLength\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastLengthUpdateBlock\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastLengthUpdateEpoch\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastRunEpoch\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> EpochManagerV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> EpochManagerV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn last_length_update_epoch(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastLengthUpdateEpoch", ()).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn last_run_epoch(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastRunEpoch", ()).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn epoch_length(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("epochLength", ()).await
    }
    pub async fn last_length_update_block(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastLengthUpdateBlock", ()).await
    }
}
pub struct StakingV1<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for StakingV1<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> StakingV1<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocation\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"poi\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"isDelegator\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"AllocationClosed\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"curationFees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"rebateFees\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"AllocationCollected\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"metadata\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"AllocationCreated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"caller\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"assetHolder\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"AssetHolderUpdate\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint32\",\n        \"name\": \"indexingRewardCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint32\",\n        \"name\": \"queryFeeCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint32\",\n        \"name\": \"cooldownBlocks\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"DelegationParametersUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"forEpoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"unclaimedAllocationsCount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"delegationFees\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"RebateClaimed\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"SetOperator\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"caller\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"slasher\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"SlasherUpdate\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"delegator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeDelegated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"delegator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"until\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeDelegatedLocked\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"delegator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeDelegatedWithdrawn\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeDeposited\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"until\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeLocked\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"reward\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"beneficiary\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"StakeSlashed\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeWithdrawn\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"acceptProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptProxyAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"allocate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"allocateFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allocations\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"createdAtEpoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"closedAtEpoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"collectedFees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocation\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsPerAllocatedToken\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"alphaDenominator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"alphaNumerator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"assetHolders\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"channelDisputeEpochs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_restake\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"claim\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address[]\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address[]\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_restake\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"claimMany\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_poi\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"closeAllocation\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"address\",\n            \"name\": \"allocationID\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"poi\",\n            \"type\": \"bytes32\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.CloseAllocationRequest[]\",\n        \"name\": \"_requests\",\n        \"type\": \"tuple[]\"\n      }\n    ],\n    \"name\": \"closeAllocationMany\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_closingAllocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_poi\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"closeAndAllocate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"collect\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"curationPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"delegate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationParametersCooldown\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"delegationPools\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"cooldownBlocks\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"indexingRewardCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"queryFeeCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"updatedAtBlock\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationRatio\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationTaxPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationUnbondingPeriod\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getAllocation\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"address\",\n            \"name\": \"indexer\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokens\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"createdAtEpoch\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"closedAtEpoch\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"collectedFees\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"effectiveAllocation\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"accRewardsPerAllocatedToken\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.Allocation\",\n        \"name\": \"\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getAllocationState\",\n    \"outputs\": [\n      {\n        \"internalType\": \"enum IStakingV1.AllocationState\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_delegator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getDelegation\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"shares\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLocked\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLockedUntil\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.Delegation\",\n        \"name\": \"\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getIndexerCapacity\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getIndexerStakedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getSubgraphAllocatedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"shares\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLocked\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLockedUntil\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.Delegation\",\n        \"name\": \"_delegation\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"name\": \"getWithdraweableDelegatedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"hasStake\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumIndexerStake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_thawingPeriod\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_protocolPercentage\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_curationPercentage\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_channelDisputeEpochs\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_maxAllocationEpochs\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationUnbondingPeriod\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_rebateAlphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_rebateAlphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isAllocation\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_delegator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isDelegator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isOperator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"maxAllocationEpochs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"minimumIndexerStake\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"operatorAuth\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"protocolPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"rebates\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocatedStake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"claimedRewards\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"unclaimedAllocationsCount\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_assetHolder\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setAssetHolder\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_channelDisputeEpochs\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setChannelDisputeEpochs\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setCurationPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_indexingRewardCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_queryFeeCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_cooldownBlocks\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationParameters\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_blocks\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationParametersCooldown\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationRatio\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationTaxPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationUnbondingPeriod\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationUnbondingPeriod\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_maxAllocationEpochs\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setMaxAllocationEpochs\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumIndexerStake\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setMinimumIndexerStake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setOperator\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setProtocolPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setRebateRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_slasher\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setSlasher\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_thawingPeriod\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setThawingPeriod\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_reward\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_beneficiary\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"slash\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"slashers\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"stake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"stakeTo\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"stakes\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensStaked\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensAllocated\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensLocked\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensLockedUntil\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"subgraphAllocations\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"thawingPeriod\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"undelegate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"unstake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_delegateToIndexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"withdrawDelegated\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> StakingV1<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn initialize(
        &self,
        controller: ::web3::types::Address,
        minimum_indexer_stake: ::web3::types::U256,
        thawing_period: u32,
        protocol_percentage: u32,
        curation_percentage: u32,
        channel_dispute_epochs: u32,
        max_allocation_epochs: u32,
        delegation_unbonding_period: u32,
        delegation_ratio: u32,
        rebate_alpha_numerator: u32,
        rebate_alpha_denominator: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "initialize",
                (
                    controller,
                    minimum_indexer_stake,
                    thawing_period,
                    protocol_percentage,
                    curation_percentage,
                    channel_dispute_epochs,
                    max_allocation_epochs,
                    delegation_unbonding_period,
                    delegation_ratio,
                    rebate_alpha_numerator,
                    rebate_alpha_denominator,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn collect(
        &self,
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("collect", (tokens, allocation_id), None, None)
            .await
    }
    pub async fn set_delegation_unbonding_period(
        &self,
        delegation_unbonding_period: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setDelegationUnbondingPeriod",
                delegation_unbonding_period,
                None,
                None,
            )
            .await
    }
    pub async fn set_operator(
        &self,
        operator: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setOperator", (operator, allowed), None, None)
            .await
    }
    pub async fn set_protocol_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setProtocolPercentage", percentage, None, None)
            .await
    }
    pub async fn undelegate(
        &self,
        indexer: ::web3::types::Address,
        shares: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("undelegate", (indexer, shares), None, None)
            .await
    }
    pub async fn close_and_allocate(
        &self,
        closing_allocation_id: ::web3::types::Address,
        poi: [u8; 32usize],
        indexer: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "closeAndAllocate",
                (
                    closing_allocation_id,
                    poi,
                    indexer,
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn allocate_from(
        &self,
        indexer: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "allocateFrom",
                (
                    indexer,
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn set_rebate_ratio(
        &self,
        alpha_numerator: u32,
        alpha_denominator: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setRebateRatio",
                (alpha_numerator, alpha_denominator),
                None,
                None,
            )
            .await
    }
    pub async fn slash(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
        reward: ::web3::types::U256,
        beneficiary: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("slash", (indexer, tokens, reward, beneficiary), None, None)
            .await
    }
    pub async fn set_delegation_ratio(
        &self,
        delegation_ratio: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationRatio", delegation_ratio, None, None)
            .await
    }
    pub async fn withdraw(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("withdraw", (), None, None).await
    }
    pub async fn close_allocation(
        &self,
        allocation_id: ::web3::types::Address,
        poi: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("closeAllocation", (allocation_id, poi), None, None)
            .await
    }
    pub async fn set_asset_holder(
        &self,
        asset_holder: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setAssetHolder", (asset_holder, allowed), None, None)
            .await
    }
    pub async fn set_minimum_indexer_stake(
        &self,
        minimum_indexer_stake: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setMinimumIndexerStake", minimum_indexer_stake, None, None)
            .await
    }
    pub async fn set_delegation_parameters_cooldown(
        &self,
        blocks: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationParametersCooldown", blocks, None, None)
            .await
    }
    pub async fn set_delegation_parameters(
        &self,
        indexing_reward_cut: u32,
        query_fee_cut: u32,
        cooldown_blocks: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setDelegationParameters",
                (indexing_reward_cut, query_fee_cut, cooldown_blocks),
                None,
                None,
            )
            .await
    }
    pub async fn stake(
        &self,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("stake", tokens, None, None).await
    }
    pub async fn close_allocation_many(
        &self,
        requests: ::solidity_bindgen::internal::Unimplemented,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("closeAllocationMany", requests, None, None)
            .await
    }
    pub async fn delegate(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("delegate", (indexer, tokens), None, None)
            .await
    }
    pub async fn accept_proxy_and_call(
        &self,
        proxy: ::web3::types::Address,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptProxyAndCall", (proxy, data), None, None)
            .await
    }
    pub async fn set_thawing_period(
        &self,
        thawing_period: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setThawingPeriod", thawing_period, None, None)
            .await
    }
    pub async fn stake_to(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("stakeTo", (indexer, tokens), None, None)
            .await
    }
    pub async fn set_delegation_tax_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationTaxPercentage", percentage, None, None)
            .await
    }
    pub async fn claim(
        &self,
        allocation_id: ::web3::types::Address,
        restake: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("claim", (allocation_id, restake), None, None)
            .await
    }
    pub async fn set_slasher(
        &self,
        slasher: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setSlasher", (slasher, allowed), None, None)
            .await
    }
    pub async fn accept_proxy(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptProxy", proxy, None, None).await
    }
    pub async fn claim_many(
        &self,
        allocation_id: ::std::vec::Vec<::web3::types::Address>,
        restake: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("claimMany", (allocation_id, restake), None, None)
            .await
    }
    pub async fn unstake(
        &self,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("unstake", tokens, None, None).await
    }
    pub async fn set_curation_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setCurationPercentage", percentage, None, None)
            .await
    }
    pub async fn allocate(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "allocate",
                (
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn set_max_allocation_epochs(
        &self,
        max_allocation_epochs: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setMaxAllocationEpochs", max_allocation_epochs, None, None)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
    pub async fn set_channel_dispute_epochs(
        &self,
        channel_dispute_epochs: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setChannelDisputeEpochs",
                channel_dispute_epochs,
                None,
                None,
            )
            .await
    }
    pub async fn withdraw_delegated(
        &self,
        indexer: ::web3::types::Address,
        delegate_to_indexer: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "withdrawDelegated",
                (indexer, delegate_to_indexer),
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> StakingV1<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn max_allocation_epochs(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("maxAllocationEpochs", ()).await
    }
    pub async fn get_withdraweable_delegated_tokens(
        &self,
        delegation: (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getWithdraweableDelegatedTokens", delegation)
            .await
    }
    pub async fn delegation_tax_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationTaxPercentage", ()).await
    }
    pub async fn allocations(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::Address,
            [u8; 32usize],
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("allocations", input_0).await
    }
    pub async fn delegation_ratio(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationRatio", ()).await
    }
    pub async fn operator_auth(
        &self,
        input_0: ::web3::types::Address,
        input_1: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("operatorAuth", (input_0, input_1)).await
    }
    pub async fn thawing_period(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("thawingPeriod", ()).await
    }
    pub async fn is_allocation(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isAllocation", allocation_id).await
    }
    pub async fn asset_holders(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("assetHolders", input_0).await
    }
    pub async fn alpha_denominator(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("alphaDenominator", ()).await
    }
    pub async fn delegation_parameters_cooldown(
        &self,
    ) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationParametersCooldown", ()).await
    }
    pub async fn get_subgraph_allocated_tokens(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getSubgraphAllocatedTokens", subgraph_deployment_id)
            .await
    }
    pub async fn subgraph_allocations(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("subgraphAllocations", input_0).await
    }
    pub async fn alpha_numerator(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("alphaNumerator", ()).await
    }
    pub async fn get_delegation(
        &self,
        indexer: ::web3::types::Address,
        delegator: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider
            .call("getDelegation", (indexer, delegator))
            .await
    }
    pub async fn protocol_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("protocolPercentage", ()).await
    }
    pub async fn curation_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("curationPercentage", ()).await
    }
    pub async fn delegation_unbonding_period(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationUnbondingPeriod", ()).await
    }
    pub async fn get_indexer_capacity(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getIndexerCapacity", indexer).await
    }
    pub async fn has_stake(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("hasStake", indexer).await
    }
    pub async fn channel_dispute_epochs(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("channelDisputeEpochs", ()).await
    }
    pub async fn get_indexer_staked_tokens(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getIndexerStakedTokens", indexer).await
    }
    pub async fn is_operator(
        &self,
        operator: ::web3::types::Address,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isOperator", (operator, indexer)).await
    }
    pub async fn get_allocation_state(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<u8, ::web3::Error> {
        self.provider
            .call("getAllocationState", allocation_id)
            .await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn delegation_pools(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            u32,
            u32,
            u32,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("delegationPools", input_0).await
    }
    pub async fn is_delegator(
        &self,
        indexer: ::web3::types::Address,
        delegator: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("isDelegator", (indexer, delegator))
            .await
    }
    pub async fn stakes(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("stakes", input_0).await
    }
    pub async fn get_allocation(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::Address,
            [u8; 32usize],
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("getAllocation", allocation_id).await
    }
    pub async fn minimum_indexer_stake(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("minimumIndexerStake", ()).await
    }
    pub async fn slashers(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("slashers", input_0).await
    }
    pub async fn rebates(
        &self,
        input_0: ::web3::types::U256,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            u32,
            u32,
            u32,
        ),
        ::web3::Error,
    > {
        self.provider.call("rebates", input_0).await
    }
}
pub struct ServiceRegistry<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for ServiceRegistry<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> ServiceRegistry<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"url\",\n        \"type\": \"string\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"geohash\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ServiceRegistered\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"ServiceUnregistered\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"acceptProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptProxyAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isRegistered\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_url\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_geohash\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"register\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_url\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_geohash\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"registerFor\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"services\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"url\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"geohash\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"unregister\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"unregisterFor\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> ServiceRegistry<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn unregister_for(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("unregisterFor", indexer, None, None)
            .await
    }
    pub async fn accept_proxy_and_call(
        &self,
        proxy: ::web3::types::Address,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptProxyAndCall", (proxy, data), None, None)
            .await
    }
    pub async fn accept_proxy(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptProxy", proxy, None, None).await
    }
    pub async fn register_for(
        &self,
        indexer: ::web3::types::Address,
        url: ::std::string::String,
        geohash: ::std::string::String,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("registerFor", (indexer, url, geohash), None, None)
            .await
    }
    pub async fn register(
        &self,
        url: ::std::string::String,
        geohash: ::std::string::String,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("register", (url, geohash), None, None)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
    pub async fn initialize(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("initialize", controller, None, None)
            .await
    }
    pub async fn unregister(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("unregister", (), None, None).await
    }
}
impl<SolidityBindgenProvider> ServiceRegistry<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn is_registered(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isRegistered", indexer).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn services(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<(::std::string::String, ::std::string::String), ::web3::Error> {
        self.provider.call("services", input_0).await
    }
}
pub struct RewardsManagerV1Storage<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone
    for RewardsManagerV1Storage<SolidityBindgenProvider>
{
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> RewardsManagerV1Storage<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"accRewardsPerSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"accRewardsPerSignalLastBlockUpdated\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"denylist\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"issuanceRate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"subgraphAvailabilityOracle\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"subgraphs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsForSubgraph\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsForSubgraphSnapshot\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsPerSignalSnapshot\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsPerAllocatedToken\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> RewardsManagerV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> RewardsManagerV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn acc_rewards_per_signal(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("accRewardsPerSignal", ()).await
    }
    pub async fn acc_rewards_per_signal_last_block_updated(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("accRewardsPerSignalLastBlockUpdated", ())
            .await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn issuance_rate(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("issuanceRate", ()).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn subgraphs(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("subgraphs", input_0).await
    }
    pub async fn subgraph_availability_oracle(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("subgraphAvailabilityOracle", ()).await
    }
    pub async fn denylist(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("denylist", input_0).await
    }
}
pub struct IEpochManager<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IEpochManager<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IEpochManager<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_block\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"blockHash\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"blockNum\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"currentEpoch\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"currentEpochBlock\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"currentEpochBlockSinceStart\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_epoch\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"epochsSince\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"epochsSinceUpdate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"isCurrentEpochRun\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"runEpoch\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_epochLength\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setEpochLength\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IEpochManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn run_epoch(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("runEpoch", (), None, None).await
    }
    pub async fn set_epoch_length(
        &self,
        epoch_length: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setEpochLength", epoch_length, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IEpochManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn current_epoch(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("currentEpoch", ()).await
    }
    pub async fn block_num(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("blockNum", ()).await
    }
    pub async fn epochs_since(
        &self,
        epoch: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("epochsSince", epoch).await
    }
    pub async fn current_epoch_block(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("currentEpochBlock", ()).await
    }
    pub async fn current_epoch_block_since_start(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("currentEpochBlockSinceStart", ()).await
    }
    pub async fn epochs_since_update(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("epochsSinceUpdate", ()).await
    }
    pub async fn is_current_epoch_run(&self) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isCurrentEpochRun", ()).await
    }
    pub async fn block_hash(
        &self,
        block: ::web3::types::U256,
    ) -> ::std::result::Result<[u8; 32usize], ::web3::Error> {
        self.provider.call("blockHash", block).await
    }
}
pub struct EthereumDIDRegistry<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for EthereumDIDRegistry<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> EthereumDIDRegistry<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"name\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes\",\n        \"name\": \"value\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"validTo\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"previousChange\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"DIDAttributeChanged\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"delegateType\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"delegate\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"validTo\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"previousChange\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"DIDDelegateChanged\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"previousChange\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"DIDOwnerChanged\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"delegateType\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"delegate\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"validity\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"addDelegate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"sigV\",\n        \"type\": \"uint8\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"sigR\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"sigS\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"delegateType\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"delegate\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"validity\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"addDelegateSigned\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"newOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"changeOwner\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"sigV\",\n        \"type\": \"uint8\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"sigR\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"sigS\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"newOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"changeOwnerSigned\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"changed\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"delegates\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"identityOwner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"nonce\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"owners\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"name\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"value\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"revokeAttribute\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"sigV\",\n        \"type\": \"uint8\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"sigR\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"sigS\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"name\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"value\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"revokeAttributeSigned\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"delegateType\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"delegate\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"revokeDelegate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"sigV\",\n        \"type\": \"uint8\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"sigR\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"sigS\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"delegateType\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"delegate\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"revokeDelegateSigned\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"name\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"value\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"validity\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setAttribute\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"sigV\",\n        \"type\": \"uint8\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"sigR\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"sigS\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"name\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"value\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"validity\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setAttributeSigned\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"delegateType\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"delegate\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"validDelegate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> EthereumDIDRegistry<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn revoke_attribute_signed(
        &self,
        identity: ::web3::types::Address,
        sig_v: u8,
        sig_r: [u8; 32usize],
        sig_s: [u8; 32usize],
        name: [u8; 32usize],
        value: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "revokeAttributeSigned",
                (identity, sig_v, sig_r, sig_s, name, value),
                None,
                None,
            )
            .await
    }
    pub async fn revoke_attribute(
        &self,
        identity: ::web3::types::Address,
        name: [u8; 32usize],
        value: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("revokeAttribute", (identity, name, value), None, None)
            .await
    }
    pub async fn add_delegate_signed(
        &self,
        identity: ::web3::types::Address,
        sig_v: u8,
        sig_r: [u8; 32usize],
        sig_s: [u8; 32usize],
        delegate_type: [u8; 32usize],
        delegate: ::web3::types::Address,
        validity: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "addDelegateSigned",
                (
                    identity,
                    sig_v,
                    sig_r,
                    sig_s,
                    delegate_type,
                    delegate,
                    validity,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn set_attribute_signed(
        &self,
        identity: ::web3::types::Address,
        sig_v: u8,
        sig_r: [u8; 32usize],
        sig_s: [u8; 32usize],
        name: [u8; 32usize],
        value: ::std::vec::Vec<u8>,
        validity: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setAttributeSigned",
                (identity, sig_v, sig_r, sig_s, name, value, validity),
                None,
                None,
            )
            .await
    }
    pub async fn set_attribute(
        &self,
        identity: ::web3::types::Address,
        name: [u8; 32usize],
        value: ::std::vec::Vec<u8>,
        validity: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setAttribute",
                (identity, name, value, validity),
                None,
                None,
            )
            .await
    }
    pub async fn revoke_delegate(
        &self,
        identity: ::web3::types::Address,
        delegate_type: [u8; 32usize],
        delegate: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "revokeDelegate",
                (identity, delegate_type, delegate),
                None,
                None,
            )
            .await
    }
    pub async fn change_owner(
        &self,
        identity: ::web3::types::Address,
        new_owner: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("changeOwner", (identity, new_owner), None, None)
            .await
    }
    pub async fn change_owner_signed(
        &self,
        identity: ::web3::types::Address,
        sig_v: u8,
        sig_r: [u8; 32usize],
        sig_s: [u8; 32usize],
        new_owner: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "changeOwnerSigned",
                (identity, sig_v, sig_r, sig_s, new_owner),
                None,
                None,
            )
            .await
    }
    pub async fn revoke_delegate_signed(
        &self,
        identity: ::web3::types::Address,
        sig_v: u8,
        sig_r: [u8; 32usize],
        sig_s: [u8; 32usize],
        delegate_type: [u8; 32usize],
        delegate: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "revokeDelegateSigned",
                (identity, sig_v, sig_r, sig_s, delegate_type, delegate),
                None,
                None,
            )
            .await
    }
    pub async fn add_delegate(
        &self,
        identity: ::web3::types::Address,
        delegate_type: [u8; 32usize],
        delegate: ::web3::types::Address,
        validity: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "addDelegate",
                (identity, delegate_type, delegate, validity),
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> EthereumDIDRegistry<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn changed(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("changed", input_0).await
    }
    pub async fn owners(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("owners", input_0).await
    }
    pub async fn identity_owner(
        &self,
        identity: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("identityOwner", identity).await
    }
    pub async fn nonce(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("nonce", input_0).await
    }
    pub async fn valid_delegate(
        &self,
        identity: ::web3::types::Address,
        delegate_type: [u8; 32usize],
        delegate: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("validDelegate", (identity, delegate_type, delegate))
            .await
    }
    pub async fn delegates(
        &self,
        input_0: ::web3::types::Address,
        input_1: [u8; 32usize],
        input_2: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("delegates", (input_0, input_1, input_2))
            .await
    }
}
pub struct GraphProxyStorage<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GraphProxyStorage<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GraphProxyStorage<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"oldAdmin\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"newAdmin\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"AdminUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"oldImplementation\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"newImplementation\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"ImplementationUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"oldPendingImplementation\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"newPendingImplementation\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"PendingImplementationUpdated\",\n    \"type\": \"event\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GraphProxyStorage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
}
impl<SolidityBindgenProvider> GraphProxyStorage<SolidityBindgenProvider> where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider
{
}
pub struct RewardsManagerMock<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for RewardsManagerMock<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> RewardsManagerMock<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"x\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"n\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"base\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"pow\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"z\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"pure\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> RewardsManagerMock<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
}
impl<SolidityBindgenProvider> RewardsManagerMock<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn pow(
        &self,
        x: ::web3::types::U256,
        n: ::web3::types::U256,
        base: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("pow", (x, n, base)).await
    }
}
pub struct StakingV2Storage<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for StakingV2Storage<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> StakingV2Storage<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allocations\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"createdAtEpoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"closedAtEpoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"collectedFees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocation\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsPerAllocatedToken\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"alphaDenominator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"alphaNumerator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"assetHolders\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"channelDisputeEpochs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"curationPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationParametersCooldown\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"delegationPools\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"cooldownBlocks\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"indexingRewardCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"queryFeeCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"updatedAtBlock\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationRatio\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationTaxPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationUnbondingPeriod\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"maxAllocationEpochs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"minimumIndexerStake\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"operatorAuth\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"protocolPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"rebates\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocatedStake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"claimedRewards\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"unclaimedAllocationsCount\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"rewardsDestination\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"slashers\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"stakes\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensStaked\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensAllocated\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensLocked\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensLockedUntil\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"subgraphAllocations\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"thawingPeriod\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> StakingV2Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> StakingV2Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn max_allocation_epochs(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("maxAllocationEpochs", ()).await
    }
    pub async fn rebates(
        &self,
        input_0: ::web3::types::U256,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            u32,
            u32,
            u32,
        ),
        ::web3::Error,
    > {
        self.provider.call("rebates", input_0).await
    }
    pub async fn slashers(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("slashers", input_0).await
    }
    pub async fn delegation_tax_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationTaxPercentage", ()).await
    }
    pub async fn delegation_unbonding_period(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationUnbondingPeriod", ()).await
    }
    pub async fn minimum_indexer_stake(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("minimumIndexerStake", ()).await
    }
    pub async fn channel_dispute_epochs(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("channelDisputeEpochs", ()).await
    }
    pub async fn stakes(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("stakes", input_0).await
    }
    pub async fn thawing_period(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("thawingPeriod", ()).await
    }
    pub async fn delegation_parameters_cooldown(
        &self,
    ) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationParametersCooldown", ()).await
    }
    pub async fn asset_holders(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("assetHolders", input_0).await
    }
    pub async fn curation_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("curationPercentage", ()).await
    }
    pub async fn alpha_numerator(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("alphaNumerator", ()).await
    }
    pub async fn subgraph_allocations(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("subgraphAllocations", input_0).await
    }
    pub async fn delegation_ratio(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationRatio", ()).await
    }
    pub async fn alpha_denominator(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("alphaDenominator", ()).await
    }
    pub async fn delegation_pools(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            u32,
            u32,
            u32,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("delegationPools", input_0).await
    }
    pub async fn rewards_destination(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("rewardsDestination", input_0).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn operator_auth(
        &self,
        input_0: ::web3::types::Address,
        input_1: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("operatorAuth", (input_0, input_1)).await
    }
    pub async fn allocations(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::Address,
            [u8; 32usize],
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("allocations", input_0).await
    }
    pub async fn protocol_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("protocolPercentage", ()).await
    }
}
pub struct IEthereumDIDRegistry<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone
    for IEthereumDIDRegistry<SolidityBindgenProvider>
{
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IEthereumDIDRegistry<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"identityOwner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"identity\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"name\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"value\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"validity\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setAttribute\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IEthereumDIDRegistry<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_attribute(
        &self,
        identity: ::web3::types::Address,
        name: [u8; 32usize],
        value: ::std::vec::Vec<u8>,
        validity: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setAttribute",
                (identity, name, value, validity),
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> IEthereumDIDRegistry<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn identity_owner(
        &self,
        identity: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("identityOwner", identity).await
    }
}
pub struct BancorFormula<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for BancorFormula<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> BancorFormula<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_fromConnectorBalance\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_fromConnectorWeight\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_toConnectorBalance\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_toConnectorWeight\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"calculateCrossConnectorReturn\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_fromReserveBalance\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_fromReserveRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_toReserveBalance\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_toReserveRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"calculateCrossReserveReturn\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_supply\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_reserveBalance\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_totalRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"calculateFundCost\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_supply\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_reserveBalance\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_totalRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"calculateLiquidateReturn\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_supply\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_reserveBalance\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_reserveRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_depositAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"calculatePurchaseReturn\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_supply\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_reserveBalance\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_reserveRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_sellAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"calculateSaleReturn\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"version\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint16\",\n        \"name\": \"\",\n        \"type\": \"uint16\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> BancorFormula<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
}
impl<SolidityBindgenProvider> BancorFormula<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn calculate_sale_return(
        &self,
        supply: ::web3::types::U256,
        reserve_balance: ::web3::types::U256,
        reserve_ratio: u32,
        sell_amount: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "calculateSaleReturn",
                (supply, reserve_balance, reserve_ratio, sell_amount),
            )
            .await
    }
    pub async fn calculate_fund_cost(
        &self,
        supply: ::web3::types::U256,
        reserve_balance: ::web3::types::U256,
        total_ratio: u32,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "calculateFundCost",
                (supply, reserve_balance, total_ratio, amount),
            )
            .await
    }
    pub async fn calculate_cross_connector_return(
        &self,
        from_connector_balance: ::web3::types::U256,
        from_connector_weight: u32,
        to_connector_balance: ::web3::types::U256,
        to_connector_weight: u32,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "calculateCrossConnectorReturn",
                (
                    from_connector_balance,
                    from_connector_weight,
                    to_connector_balance,
                    to_connector_weight,
                    amount,
                ),
            )
            .await
    }
    pub async fn calculate_cross_reserve_return(
        &self,
        from_reserve_balance: ::web3::types::U256,
        from_reserve_ratio: u32,
        to_reserve_balance: ::web3::types::U256,
        to_reserve_ratio: u32,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "calculateCrossReserveReturn",
                (
                    from_reserve_balance,
                    from_reserve_ratio,
                    to_reserve_balance,
                    to_reserve_ratio,
                    amount,
                ),
            )
            .await
    }
    pub async fn calculate_liquidate_return(
        &self,
        supply: ::web3::types::U256,
        reserve_balance: ::web3::types::U256,
        total_ratio: u32,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "calculateLiquidateReturn",
                (supply, reserve_balance, total_ratio, amount),
            )
            .await
    }
    pub async fn calculate_purchase_return(
        &self,
        supply: ::web3::types::U256,
        reserve_balance: ::web3::types::U256,
        reserve_ratio: u32,
        deposit_amount: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "calculatePurchaseReturn",
                (supply, reserve_balance, reserve_ratio, deposit_amount),
            )
            .await
    }
    pub async fn version(&self) -> ::std::result::Result<u16, ::web3::Error> {
        self.provider.call("version", ()).await
    }
}
pub struct Pausable<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for Pausable<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> Pausable<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"oldPauseGuardian\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"pauseGuardian\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewPauseGuardian\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"isPaused\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"PartialPauseChanged\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"isPaused\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"PauseChanged\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastPausePartialTime\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastPauseTime\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pauseGuardian\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> Pausable<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
}
impl<SolidityBindgenProvider> Pausable<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn last_pause_partial_time(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastPausePartialTime", ()).await
    }
    pub async fn last_pause_time(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastPauseTime", ()).await
    }
    pub async fn pause_guardian(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("pauseGuardian", ()).await
    }
}
pub struct Governed<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for Governed<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> Governed<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewPendingOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"acceptOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"governor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingGovernor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newGovernor\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> Governed<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn accept_ownership(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptOwnership", (), None, None).await
    }
    pub async fn transfer_ownership(
        &self,
        new_governor: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferOwnership", new_governor, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> Governed<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn pending_governor(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("pendingGovernor", ()).await
    }
    pub async fn governor(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("governor", ()).await
    }
}
pub struct RebatePoolMock<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for RebatePoolMock<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> RebatePoolMock<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Redeemed\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_indexerFees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_indexerAllocatedStake\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"add\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"alphaDenominator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"alphaNumerator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_totalRewards\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_fees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_totalFees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_stake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_totalStake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"cobbDouglas\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"pure\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_indexerFees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_indexerAllocatedStake\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"pop\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"rebatePool\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocatedStake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"claimedRewards\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"unclaimedAllocationsCount\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setRebateRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> RebatePoolMock<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn pop(
        &self,
        indexer_fees: ::web3::types::U256,
        indexer_allocated_stake: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("pop", (indexer_fees, indexer_allocated_stake), None, None)
            .await
    }
    pub async fn add(
        &self,
        indexer_fees: ::web3::types::U256,
        indexer_allocated_stake: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("add", (indexer_fees, indexer_allocated_stake), None, None)
            .await
    }
    pub async fn set_rebate_ratio(
        &self,
        alpha_numerator: u32,
        alpha_denominator: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setRebateRatio",
                (alpha_numerator, alpha_denominator),
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> RebatePoolMock<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn rebate_pool(
        &self,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            u32,
            u32,
            u32,
        ),
        ::web3::Error,
    > {
        self.provider.call("rebatePool", ()).await
    }
    pub async fn alpha_denominator(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("alphaDenominator", ()).await
    }
    pub async fn cobb_douglas(
        &self,
        total_rewards: ::web3::types::U256,
        fees: ::web3::types::U256,
        total_fees: ::web3::types::U256,
        stake: ::web3::types::U256,
        total_stake: ::web3::types::U256,
        alpha_numerator: u32,
        alpha_denominator: u32,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "cobbDouglas",
                (
                    total_rewards,
                    fees,
                    total_fees,
                    stake,
                    total_stake,
                    alpha_numerator,
                    alpha_denominator,
                ),
            )
            .await
    }
    pub async fn alpha_numerator(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("alphaNumerator", ()).await
    }
}
pub struct GovernedMock<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GovernedMock<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GovernedMock<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewPendingOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"acceptOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"governor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingGovernor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newGovernor\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GovernedMock<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn accept_ownership(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptOwnership", (), None, None).await
    }
    pub async fn transfer_ownership(
        &self,
        new_governor: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferOwnership", new_governor, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> GovernedMock<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn governor(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("governor", ()).await
    }
    pub async fn pending_governor(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("pendingGovernor", ()).await
    }
}
pub struct RewardsManager<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for RewardsManager<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> RewardsManager<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"RewardsAssigned\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"RewardsDenied\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"sinceBlock\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"RewardsDenylistUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"accRewardsPerSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"accRewardsPerSignalLastBlockUpdated\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"acceptProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptProxyAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"denylist\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getAccRewardsForSubgraph\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getAccRewardsPerAllocatedToken\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"getAccRewardsPerSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"getNewRewardsPerSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getRewards\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_issuanceRate\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"isDenied\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"issuanceRate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"onSubgraphAllocationUpdate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"onSubgraphSignalUpdate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_deny\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setDenied\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32[]\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32[]\"\n      },\n      {\n        \"internalType\": \"bool[]\",\n        \"name\": \"_deny\",\n        \"type\": \"bool[]\"\n      }\n    ],\n    \"name\": \"setDeniedMany\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_issuanceRate\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setIssuanceRate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_subgraphAvailabilityOracle\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setSubgraphAvailabilityOracle\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"subgraphAvailabilityOracle\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"subgraphs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsForSubgraph\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsForSubgraphSnapshot\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsPerSignalSnapshot\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsPerAllocatedToken\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"takeRewards\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"updateAccRewardsPerSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> RewardsManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn accept_proxy(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptProxy", proxy, None, None).await
    }
    pub async fn on_subgraph_allocation_update(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "onSubgraphAllocationUpdate",
                subgraph_deployment_id,
                None,
                None,
            )
            .await
    }
    pub async fn initialize(
        &self,
        controller: ::web3::types::Address,
        issuance_rate: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("initialize", (controller, issuance_rate), None, None)
            .await
    }
    pub async fn on_subgraph_signal_update(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("onSubgraphSignalUpdate", subgraph_deployment_id, None, None)
            .await
    }
    pub async fn set_denied(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        deny: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDenied", (subgraph_deployment_id, deny), None, None)
            .await
    }
    pub async fn accept_proxy_and_call(
        &self,
        proxy: ::web3::types::Address,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptProxyAndCall", (proxy, data), None, None)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
    pub async fn set_denied_many(
        &self,
        subgraph_deployment_id: ::std::vec::Vec<[u8; 32usize]>,
        deny: ::std::vec::Vec<bool>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDeniedMany", (subgraph_deployment_id, deny), None, None)
            .await
    }
    pub async fn set_subgraph_availability_oracle(
        &self,
        subgraph_availability_oracle: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setSubgraphAvailabilityOracle",
                subgraph_availability_oracle,
                None,
                None,
            )
            .await
    }
    pub async fn set_issuance_rate(
        &self,
        issuance_rate: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setIssuanceRate", issuance_rate, None, None)
            .await
    }
    pub async fn take_rewards(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("takeRewards", allocation_id, None, None)
            .await
    }
    pub async fn update_acc_rewards_per_signal(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("updateAccRewardsPerSignal", (), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> RewardsManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn get_acc_rewards_for_subgraph(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getAccRewardsForSubgraph", subgraph_deployment_id)
            .await
    }
    pub async fn acc_rewards_per_signal(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("accRewardsPerSignal", ()).await
    }
    pub async fn denylist(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("denylist", input_0).await
    }
    pub async fn get_acc_rewards_per_signal(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getAccRewardsPerSignal", ()).await
    }
    pub async fn get_rewards(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getRewards", allocation_id).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn subgraph_availability_oracle(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("subgraphAvailabilityOracle", ()).await
    }
    pub async fn subgraphs(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("subgraphs", input_0).await
    }
    pub async fn acc_rewards_per_signal_last_block_updated(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("accRewardsPerSignalLastBlockUpdated", ())
            .await
    }
    pub async fn get_new_rewards_per_signal(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getNewRewardsPerSignal", ()).await
    }
    pub async fn is_denied(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isDenied", subgraph_deployment_id).await
    }
    pub async fn issuance_rate(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("issuanceRate", ()).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn get_acc_rewards_per_allocated_token(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<(::web3::types::U256, ::web3::types::U256), ::web3::Error> {
        self.provider
            .call("getAccRewardsPerAllocatedToken", subgraph_deployment_id)
            .await
    }
}
pub struct StakingV1Storage<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for StakingV1Storage<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> StakingV1Storage<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allocations\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"createdAtEpoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"closedAtEpoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"collectedFees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocation\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsPerAllocatedToken\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"alphaDenominator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"alphaNumerator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"assetHolders\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"channelDisputeEpochs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"curationPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationParametersCooldown\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"delegationPools\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"cooldownBlocks\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"indexingRewardCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"queryFeeCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"updatedAtBlock\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationRatio\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationTaxPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationUnbondingPeriod\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"maxAllocationEpochs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"minimumIndexerStake\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"operatorAuth\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"protocolPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"rebates\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocatedStake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"claimedRewards\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"unclaimedAllocationsCount\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"slashers\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"stakes\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensStaked\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensAllocated\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensLocked\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensLockedUntil\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"subgraphAllocations\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"thawingPeriod\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> StakingV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> StakingV1Storage<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn curation_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("curationPercentage", ()).await
    }
    pub async fn max_allocation_epochs(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("maxAllocationEpochs", ()).await
    }
    pub async fn delegation_unbonding_period(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationUnbondingPeriod", ()).await
    }
    pub async fn alpha_numerator(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("alphaNumerator", ()).await
    }
    pub async fn delegation_parameters_cooldown(
        &self,
    ) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationParametersCooldown", ()).await
    }
    pub async fn delegation_ratio(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationRatio", ()).await
    }
    pub async fn rebates(
        &self,
        input_0: ::web3::types::U256,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            u32,
            u32,
            u32,
        ),
        ::web3::Error,
    > {
        self.provider.call("rebates", input_0).await
    }
    pub async fn stakes(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("stakes", input_0).await
    }
    pub async fn protocol_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("protocolPercentage", ()).await
    }
    pub async fn alpha_denominator(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("alphaDenominator", ()).await
    }
    pub async fn delegation_tax_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationTaxPercentage", ()).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn subgraph_allocations(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("subgraphAllocations", input_0).await
    }
    pub async fn operator_auth(
        &self,
        input_0: ::web3::types::Address,
        input_1: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("operatorAuth", (input_0, input_1)).await
    }
    pub async fn minimum_indexer_stake(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("minimumIndexerStake", ()).await
    }
    pub async fn allocations(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::Address,
            [u8; 32usize],
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("allocations", input_0).await
    }
    pub async fn delegation_pools(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            u32,
            u32,
            u32,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("delegationPools", input_0).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn channel_dispute_epochs(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("channelDisputeEpochs", ()).await
    }
    pub async fn slashers(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("slashers", input_0).await
    }
    pub async fn asset_holders(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("assetHolders", input_0).await
    }
    pub async fn thawing_period(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("thawingPeriod", ()).await
    }
}
pub struct IManaged<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IManaged<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IManaged<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IManaged<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IManaged<SolidityBindgenProvider> where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider
{
}
pub struct ERC20<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for ERC20<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> ERC20<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"name_\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"symbol_\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"subtractedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"decreaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"addedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"increaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> ERC20<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn increase_allowance(
        &self,
        spender: ::web3::types::Address,
        added_value: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("increaseAllowance", (spender, added_value), None, None)
            .await
    }
    pub async fn decrease_allowance(
        &self,
        spender: ::web3::types::Address,
        subtracted_value: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("decreaseAllowance", (spender, subtracted_value), None, None)
            .await
    }
    pub async fn transfer(
        &self,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transfer", (recipient, amount), None, None)
            .await
    }
    pub async fn approve(
        &self,
        spender: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("approve", (spender, amount), None, None)
            .await
    }
    pub async fn transfer_from(
        &self,
        sender: ::web3::types::Address,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferFrom", (sender, recipient, amount), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> ERC20<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn name(&self) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("name", ()).await
    }
    pub async fn allowance(
        &self,
        owner: ::web3::types::Address,
        spender: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("allowance", (owner, spender)).await
    }
    pub async fn total_supply(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("totalSupply", ()).await
    }
    pub async fn symbol(&self) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("symbol", ()).await
    }
    pub async fn balance_of(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("balanceOf", account).await
    }
    pub async fn decimals(&self) -> ::std::result::Result<u8, ::web3::Error> {
        self.provider.call("decimals", ()).await
    }
}
pub struct IERC20<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IERC20<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IERC20<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IERC20<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn approve(
        &self,
        spender: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("approve", (spender, amount), None, None)
            .await
    }
    pub async fn transfer(
        &self,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transfer", (recipient, amount), None, None)
            .await
    }
    pub async fn transfer_from(
        &self,
        sender: ::web3::types::Address,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferFrom", (sender, recipient, amount), None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IERC20<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn allowance(
        &self,
        owner: ::web3::types::Address,
        spender: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("allowance", (owner, spender)).await
    }
    pub async fn balance_of(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("balanceOf", account).await
    }
    pub async fn total_supply(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("totalSupply", ()).await
    }
}
pub struct GraphCurationToken<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GraphCurationToken<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GraphCurationToken<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"NewPendingOwnership\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"acceptOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_account\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burnFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"subtractedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"decreaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"governor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"addedValue\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"increaseAllowance\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingGovernor\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"recipient\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_newGovernor\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GraphCurationToken<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn transfer(
        &self,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transfer", (recipient, amount), None, None)
            .await
    }
    pub async fn transfer_ownership(
        &self,
        new_governor: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferOwnership", new_governor, None, None)
            .await
    }
    pub async fn increase_allowance(
        &self,
        spender: ::web3::types::Address,
        added_value: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("increaseAllowance", (spender, added_value), None, None)
            .await
    }
    pub async fn accept_ownership(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptOwnership", (), None, None).await
    }
    pub async fn transfer_from(
        &self,
        sender: ::web3::types::Address,
        recipient: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("transferFrom", (sender, recipient, amount), None, None)
            .await
    }
    pub async fn approve(
        &self,
        spender: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("approve", (spender, amount), None, None)
            .await
    }
    pub async fn burn_from(
        &self,
        account: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("burnFrom", (account, amount), None, None)
            .await
    }
    pub async fn decrease_allowance(
        &self,
        spender: ::web3::types::Address,
        subtracted_value: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("decreaseAllowance", (spender, subtracted_value), None, None)
            .await
    }
    pub async fn mint(
        &self,
        to: ::web3::types::Address,
        amount: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("mint", (to, amount), None, None).await
    }
}
impl<SolidityBindgenProvider> GraphCurationToken<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn balance_of(
        &self,
        account: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("balanceOf", account).await
    }
    pub async fn governor(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("governor", ()).await
    }
    pub async fn decimals(&self) -> ::std::result::Result<u8, ::web3::Error> {
        self.provider.call("decimals", ()).await
    }
    pub async fn allowance(
        &self,
        owner: ::web3::types::Address,
        spender: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("allowance", (owner, spender)).await
    }
    pub async fn name(&self) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("name", ()).await
    }
    pub async fn pending_governor(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("pendingGovernor", ()).await
    }
    pub async fn total_supply(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("totalSupply", ()).await
    }
    pub async fn symbol(&self) -> ::std::result::Result<::std::string::String, ::web3::Error> {
        self.provider.call("symbol", ()).await
    }
}
pub struct GNS<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for GNS<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> GNS<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"nameCurator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"nSignalBurnt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"withdrawnGRT\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"GRTWithdrawn\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"nameCurator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"nSignalBurnt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"vSignalBurnt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensReceived\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"NSignalBurned\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"nameCurator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"nSignalCreated\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"vSignalCreated\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensDeposited\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"NSignalMinted\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"withdrawableGRT\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"NameSignalDisabled\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint32\",\n        \"name\": \"reserveRatio\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"NameSignalEnabled\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"newVSignalCreated\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensSignalled\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"NameSignalUpgrade\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"nameSystem\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"nameIdentifier\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"name\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"SetDefaultName\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"subgraphNumber\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"SubgraphDeprecated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphMetadata\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"SubgraphMetadataUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"versionMetadata\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"SubgraphPublished\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"acceptProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptProxyAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"approveAll\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"bondingCurve\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_nSignal\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensOutMin\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"burnNSignal\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"deprecateSubgraph\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"erc1056Registry\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IEthereumDIDRegistry\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_curator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getCuratorNSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"graphAccountSubgraphNumbers\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_bondingCurve\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_didRegistry\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"isPublished\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensIn\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_nSignalOutMin\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mintNSignal\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_nSignalIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"nSignalToTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_nSignalIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"nSignalToVSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"nameSignals\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"vSignal\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"nSignal\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"reserveRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"disabled\",\n        \"type\": \"bool\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"withdrawableGRT\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"ownerTaxPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_versionMetadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphMetadata\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"publishNewSubgraph\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_versionMetadata\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"publishNewVersion\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"_nameSystem\",\n        \"type\": \"uint8\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_nameIdentifier\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_name\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"setDefaultName\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_ownerTaxPercentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setOwnerTaxPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"subgraphs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokensIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"tokensToNSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphMetadata\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"updateSubgraphMetadata\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_vSignalIn\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"vSignalToNSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_graphAccount\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_subgraphNumber\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> GNS<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn approve_all(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("approveAll", (), None, None).await
    }
    pub async fn set_default_name(
        &self,
        graph_account: ::web3::types::Address,
        name_system: u8,
        name_identifier: [u8; 32usize],
        name: ::std::string::String,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setDefaultName",
                (graph_account, name_system, name_identifier, name),
                None,
                None,
            )
            .await
    }
    pub async fn update_subgraph_metadata(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        subgraph_metadata: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "updateSubgraphMetadata",
                (graph_account, subgraph_number, subgraph_metadata),
                None,
                None,
            )
            .await
    }
    pub async fn withdraw(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("withdraw", (graph_account, subgraph_number), None, None)
            .await
    }
    pub async fn burn_n_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        n_signal: ::web3::types::U256,
        tokens_out_min: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "burnNSignal",
                (graph_account, subgraph_number, n_signal, tokens_out_min),
                None,
                None,
            )
            .await
    }
    pub async fn mint_n_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        tokens_in: ::web3::types::U256,
        n_signal_out_min: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "mintNSignal",
                (graph_account, subgraph_number, tokens_in, n_signal_out_min),
                None,
                None,
            )
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
    pub async fn initialize(
        &self,
        controller: ::web3::types::Address,
        bonding_curve: ::web3::types::Address,
        did_registry: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "initialize",
                (controller, bonding_curve, did_registry),
                None,
                None,
            )
            .await
    }
    pub async fn set_owner_tax_percentage(
        &self,
        owner_tax_percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setOwnerTaxPercentage", owner_tax_percentage, None, None)
            .await
    }
    pub async fn deprecate_subgraph(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "deprecateSubgraph",
                (graph_account, subgraph_number),
                None,
                None,
            )
            .await
    }
    pub async fn accept_proxy_and_call(
        &self,
        proxy: ::web3::types::Address,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptProxyAndCall", (proxy, data), None, None)
            .await
    }
    pub async fn publish_new_subgraph(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
        version_metadata: [u8; 32usize],
        subgraph_metadata: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "publishNewSubgraph",
                (
                    graph_account,
                    subgraph_deployment_id,
                    version_metadata,
                    subgraph_metadata,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn accept_proxy(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptProxy", proxy, None, None).await
    }
    pub async fn publish_new_version(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        subgraph_deployment_id: [u8; 32usize],
        version_metadata: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "publishNewVersion",
                (
                    graph_account,
                    subgraph_number,
                    subgraph_deployment_id,
                    version_metadata,
                ),
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> GNS<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn graph_account_subgraph_numbers(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("graphAccountSubgraphNumbers", input_0)
            .await
    }
    pub async fn bonding_curve(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("bondingCurve", ()).await
    }
    pub async fn tokens_to_n_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        tokens_in: ::web3::types::U256,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider
            .call(
                "tokensToNSignal",
                (graph_account, subgraph_number, tokens_in),
            )
            .await
    }
    pub async fn v_signal_to_n_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        v_signal_in: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "vSignalToNSignal",
                (graph_account, subgraph_number, v_signal_in),
            )
            .await
    }
    pub async fn name_signals(
        &self,
        input_0: ::web3::types::Address,
        input_1: ::web3::types::U256,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            [u8; 32usize],
            u32,
            bool,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("nameSignals", (input_0, input_1)).await
    }
    pub async fn is_published(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("isPublished", (graph_account, subgraph_number))
            .await
    }
    pub async fn n_signal_to_tokens(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        n_signal_in: ::web3::types::U256,
    ) -> ::std::result::Result<(::web3::types::U256, ::web3::types::U256), ::web3::Error> {
        self.provider
            .call(
                "nSignalToTokens",
                (graph_account, subgraph_number, n_signal_in),
            )
            .await
    }
    pub async fn n_signal_to_v_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        n_signal_in: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "nSignalToVSignal",
                (graph_account, subgraph_number, n_signal_in),
            )
            .await
    }
    pub async fn subgraphs(
        &self,
        input_0: ::web3::types::Address,
        input_1: ::web3::types::U256,
    ) -> ::std::result::Result<[u8; 32usize], ::web3::Error> {
        self.provider.call("subgraphs", (input_0, input_1)).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn get_curator_n_signal(
        &self,
        graph_account: ::web3::types::Address,
        subgraph_number: ::web3::types::U256,
        curator: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "getCuratorNSignal",
                (graph_account, subgraph_number, curator),
            )
            .await
    }
    pub async fn erc_1056_registry(
        &self,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("erc1056Registry", ()).await
    }
    pub async fn owner_tax_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("ownerTaxPercentage", ()).await
    }
}
pub struct EpochManager<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for EpochManager<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> EpochManager<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epochLength\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"EpochLengthUpdate\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"caller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"EpochRun\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"acceptProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptProxyAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_block\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"blockHash\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"blockNum\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"currentEpoch\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"currentEpochBlock\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"currentEpochBlockSinceStart\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"epochLength\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_epoch\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"epochsSince\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"epochsSinceUpdate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_epochLength\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"isCurrentEpochRun\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastLengthUpdateBlock\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastLengthUpdateEpoch\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"lastRunEpoch\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"runEpoch\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_epochLength\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setEpochLength\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> EpochManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn accept_proxy(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptProxy", proxy, None, None).await
    }
    pub async fn accept_proxy_and_call(
        &self,
        proxy: ::web3::types::Address,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptProxyAndCall", (proxy, data), None, None)
            .await
    }
    pub async fn initialize(
        &self,
        controller: ::web3::types::Address,
        epoch_length: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("initialize", (controller, epoch_length), None, None)
            .await
    }
    pub async fn run_epoch(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("runEpoch", (), None, None).await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
    pub async fn set_epoch_length(
        &self,
        epoch_length: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setEpochLength", epoch_length, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> EpochManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn last_length_update_epoch(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastLengthUpdateEpoch", ()).await
    }
    pub async fn current_epoch(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("currentEpoch", ()).await
    }
    pub async fn last_run_epoch(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastRunEpoch", ()).await
    }
    pub async fn epochs_since(
        &self,
        epoch: ::web3::types::U256,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("epochsSince", epoch).await
    }
    pub async fn block_num(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("blockNum", ()).await
    }
    pub async fn current_epoch_block(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("currentEpochBlock", ()).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn epoch_length(&self) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("epochLength", ()).await
    }
    pub async fn epochs_since_update(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("epochsSinceUpdate", ()).await
    }
    pub async fn current_epoch_block_since_start(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("currentEpochBlockSinceStart", ()).await
    }
    pub async fn is_current_epoch_run(&self) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isCurrentEpochRun", ()).await
    }
    pub async fn block_hash(
        &self,
        block: ::web3::types::U256,
    ) -> ::std::result::Result<[u8; 32usize], ::web3::Error> {
        self.provider.call("blockHash", block).await
    }
    pub async fn last_length_update_block(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("lastLengthUpdateBlock", ()).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
}
pub struct IRewardsManager<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for IRewardsManager<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> IRewardsManager<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getAccRewardsForSubgraph\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getAccRewardsPerAllocatedToken\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"getAccRewardsPerSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"getNewRewardsPerSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getRewards\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"isDenied\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"onSubgraphAllocationUpdate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"onSubgraphSignalUpdate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_deny\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setDenied\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32[]\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32[]\"\n      },\n      {\n        \"internalType\": \"bool[]\",\n        \"name\": \"_deny\",\n        \"type\": \"bool[]\"\n      }\n    ],\n    \"name\": \"setDeniedMany\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_issuanceRate\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setIssuanceRate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_subgraphAvailabilityOracle\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setSubgraphAvailabilityOracle\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"takeRewards\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"updateAccRewardsPerSignal\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> IRewardsManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn set_issuance_rate(
        &self,
        issuance_rate: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setIssuanceRate", issuance_rate, None, None)
            .await
    }
    pub async fn set_denied(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        deny: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDenied", (subgraph_deployment_id, deny), None, None)
            .await
    }
    pub async fn set_denied_many(
        &self,
        subgraph_deployment_id: ::std::vec::Vec<[u8; 32usize]>,
        deny: ::std::vec::Vec<bool>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDeniedMany", (subgraph_deployment_id, deny), None, None)
            .await
    }
    pub async fn on_subgraph_allocation_update(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "onSubgraphAllocationUpdate",
                subgraph_deployment_id,
                None,
                None,
            )
            .await
    }
    pub async fn set_subgraph_availability_oracle(
        &self,
        subgraph_availability_oracle: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setSubgraphAvailabilityOracle",
                subgraph_availability_oracle,
                None,
                None,
            )
            .await
    }
    pub async fn take_rewards(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("takeRewards", allocation_id, None, None)
            .await
    }
    pub async fn update_acc_rewards_per_signal(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("updateAccRewardsPerSignal", (), None, None)
            .await
    }
    pub async fn on_subgraph_signal_update(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("onSubgraphSignalUpdate", subgraph_deployment_id, None, None)
            .await
    }
}
impl<SolidityBindgenProvider> IRewardsManager<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn is_denied(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isDenied", subgraph_deployment_id).await
    }
    pub async fn get_acc_rewards_for_subgraph(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getAccRewardsForSubgraph", subgraph_deployment_id)
            .await
    }
    pub async fn get_acc_rewards_per_signal(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getAccRewardsPerSignal", ()).await
    }
    pub async fn get_rewards(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getRewards", allocation_id).await
    }
    pub async fn get_new_rewards_per_signal(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getNewRewardsPerSignal", ()).await
    }
    pub async fn get_acc_rewards_per_allocated_token(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<(::web3::types::U256, ::web3::types::U256), ::web3::Error> {
        self.provider
            .call("getAccRewardsPerAllocatedToken", subgraph_deployment_id)
            .await
    }
}
pub struct LibCobbDouglas<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for LibCobbDouglas<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> LibCobbDouglas<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalRewards\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalFees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"stake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"totalStake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"cobbDouglas\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"rewards\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"pure\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> LibCobbDouglas<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
}
impl<SolidityBindgenProvider> LibCobbDouglas<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn cobb_douglas(
        &self,
        total_rewards: ::web3::types::U256,
        fees: ::web3::types::U256,
        total_fees: ::web3::types::U256,
        stake: ::web3::types::U256,
        total_stake: ::web3::types::U256,
        alpha_numerator: u32,
        alpha_denominator: u32,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call(
                "cobbDouglas",
                (
                    total_rewards,
                    fees,
                    total_fees,
                    stake,
                    total_stake,
                    alpha_numerator,
                    alpha_denominator,
                ),
            )
            .await
    }
}
pub struct Staking<SolidityBindgenProvider> {
    provider: ::std::sync::Arc<SolidityBindgenProvider>,
    pub address: ::web3::types::Address,
}
impl<SolidityBindgenProvider> ::std::clone::Clone for Staking<SolidityBindgenProvider> {
    fn clone(&self) -> Self {
        Self {
            provider: ::std::clone::Clone::clone(&self.provider),
            address: self.address,
        }
    }
}
impl<SolidityBindgenProvider> Staking<SolidityBindgenProvider> {
    pub fn new<Context>(address: ::web3::types::Address, context: &Context) -> Self
    where
        Context: ::solidity_bindgen::Context<Provider = SolidityBindgenProvider>,
    {
        let abi = "[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocation\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"poi\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"isDelegator\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"AllocationClosed\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"curationFees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"rebateFees\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"AllocationCollected\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"metadata\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"AllocationCreated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"caller\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"assetHolder\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"AssetHolderUpdate\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint32\",\n        \"name\": \"indexingRewardCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint32\",\n        \"name\": \"queryFeeCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint32\",\n        \"name\": \"cooldownBlocks\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"DelegationParametersUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"param\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"ParameterUpdated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"epoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"forEpoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"unclaimedAllocationsCount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"delegationFees\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"RebateClaimed\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetController\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"SetOperator\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"destination\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"SetRewardsDestination\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"caller\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"slasher\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"SlasherUpdate\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"delegator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeDelegated\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"delegator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"until\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeDelegatedLocked\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"delegator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeDelegatedWithdrawn\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeDeposited\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"until\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeLocked\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"reward\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"beneficiary\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"StakeSlashed\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"StakeWithdrawn\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"acceptProxy\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IGraphProxy\",\n        \"name\": \"_proxy\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"acceptProxyAndCall\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"addressCache\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"allocate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"allocateFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allocations\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"createdAtEpoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"closedAtEpoch\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"collectedFees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocation\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"accRewardsPerAllocatedToken\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"alphaDenominator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"alphaNumerator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"assetHolders\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"channelDisputeEpochs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_restake\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"claim\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address[]\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address[]\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_restake\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"claimMany\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_poi\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"closeAllocation\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"address\",\n            \"name\": \"allocationID\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"poi\",\n            \"type\": \"bytes32\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.CloseAllocationRequest[]\",\n        \"name\": \"_requests\",\n        \"type\": \"tuple[]\"\n      }\n    ],\n    \"name\": \"closeAllocationMany\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_closingAllocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_poi\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_metadata\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"_proof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"closeAndAllocate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"collect\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"controller\",\n    \"outputs\": [\n      {\n        \"internalType\": \"contract IController\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"curationPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"delegate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationParametersCooldown\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"delegationPools\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"cooldownBlocks\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"indexingRewardCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"queryFeeCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"updatedAtBlock\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationRatio\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationTaxPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"delegationUnbondingPeriod\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getAllocation\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"address\",\n            \"name\": \"indexer\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes32\",\n            \"name\": \"subgraphDeploymentID\",\n            \"type\": \"bytes32\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokens\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"createdAtEpoch\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"closedAtEpoch\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"collectedFees\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"effectiveAllocation\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"accRewardsPerAllocatedToken\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.Allocation\",\n        \"name\": \"\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getAllocationState\",\n    \"outputs\": [\n      {\n        \"internalType\": \"enum IStaking.AllocationState\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_delegator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getDelegation\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"shares\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLocked\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLockedUntil\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.Delegation\",\n        \"name\": \"\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getIndexerCapacity\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getIndexerStakedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"_subgraphDeploymentID\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"getSubgraphAllocatedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"shares\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLocked\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"tokensLockedUntil\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IStakingData.Delegation\",\n        \"name\": \"_delegation\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"name\": \"getWithdraweableDelegatedTokens\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"hasStake\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumIndexerStake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_thawingPeriod\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_protocolPercentage\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_curationPercentage\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_channelDisputeEpochs\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_maxAllocationEpochs\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationUnbondingPeriod\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationRatio\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_rebateAlphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_rebateAlphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_allocationID\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isAllocation\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_delegator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isDelegator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isOperator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"maxAllocationEpochs\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"minimumIndexerStake\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"operatorAuth\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"protocolPercentage\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"rebates\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"fees\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"effectiveAllocatedStake\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"claimedRewards\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"unclaimedAllocationsCount\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"rewardsDestination\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_assetHolder\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setAssetHolder\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_channelDisputeEpochs\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setChannelDisputeEpochs\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_controller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setController\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setCurationPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_indexingRewardCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_queryFeeCut\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_cooldownBlocks\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationParameters\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_blocks\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationParametersCooldown\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationRatio\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationTaxPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_delegationUnbondingPeriod\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setDelegationUnbondingPeriod\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_maxAllocationEpochs\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setMaxAllocationEpochs\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minimumIndexerStake\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setMinimumIndexerStake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setOperator\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_percentage\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setProtocolPercentage\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaNumerator\",\n        \"type\": \"uint32\"\n      },\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_alphaDenominator\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setRebateRatio\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_destination\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setRewardsDestination\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_slasher\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"_allowed\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setSlasher\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"_thawingPeriod\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"name\": \"setThawingPeriod\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_reward\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_beneficiary\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"slash\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"slashers\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"stake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"stakeTo\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"stakes\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensStaked\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensAllocated\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensLocked\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokensLockedUntil\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"subgraphAllocations\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"thawingPeriod\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint32\",\n        \"name\": \"\",\n        \"type\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_shares\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"undelegate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_tokens\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"unstake\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"withdraw\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_indexer\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_delegateToIndexer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"withdrawDelegated\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n" ;
        let provider = ::solidity_bindgen::Context::provider(context, address, abi.as_bytes());
        let provider = ::std::sync::Arc::new(provider);
        Self { address, provider }
    }
}
impl<SolidityBindgenProvider> Staking<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::SendProvider,
{
    pub async fn send(
        &self,
        func: &'static str,
        params: impl web3::contract::tokens::Tokenize + Send,
        options: Option<::web3::contract::Options>,
        confirmations: Option<usize>,
    ) -> Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(func, params, options, confirmations)
            .await
    }
    pub async fn accept_proxy(
        &self,
        proxy: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("acceptProxy", proxy, None, None).await
    }
    pub async fn set_minimum_indexer_stake(
        &self,
        minimum_indexer_stake: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setMinimumIndexerStake", minimum_indexer_stake, None, None)
            .await
    }
    pub async fn allocate(
        &self,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "allocate",
                (
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn initialize(
        &self,
        controller: ::web3::types::Address,
        minimum_indexer_stake: ::web3::types::U256,
        thawing_period: u32,
        protocol_percentage: u32,
        curation_percentage: u32,
        channel_dispute_epochs: u32,
        max_allocation_epochs: u32,
        delegation_unbonding_period: u32,
        delegation_ratio: u32,
        rebate_alpha_numerator: u32,
        rebate_alpha_denominator: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "initialize",
                (
                    controller,
                    minimum_indexer_stake,
                    thawing_period,
                    protocol_percentage,
                    curation_percentage,
                    channel_dispute_epochs,
                    max_allocation_epochs,
                    delegation_unbonding_period,
                    delegation_ratio,
                    rebate_alpha_numerator,
                    rebate_alpha_denominator,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn delegate(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("delegate", (indexer, tokens), None, None)
            .await
    }
    pub async fn set_channel_dispute_epochs(
        &self,
        channel_dispute_epochs: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setChannelDisputeEpochs",
                channel_dispute_epochs,
                None,
                None,
            )
            .await
    }
    pub async fn allocate_from(
        &self,
        indexer: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "allocateFrom",
                (
                    indexer,
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn set_delegation_ratio(
        &self,
        delegation_ratio: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationRatio", delegation_ratio, None, None)
            .await
    }
    pub async fn set_thawing_period(
        &self,
        thawing_period: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setThawingPeriod", thawing_period, None, None)
            .await
    }
    pub async fn claim(
        &self,
        allocation_id: ::web3::types::Address,
        restake: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("claim", (allocation_id, restake), None, None)
            .await
    }
    pub async fn claim_many(
        &self,
        allocation_id: ::std::vec::Vec<::web3::types::Address>,
        restake: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("claimMany", (allocation_id, restake), None, None)
            .await
    }
    pub async fn accept_proxy_and_call(
        &self,
        proxy: ::web3::types::Address,
        data: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("acceptProxyAndCall", (proxy, data), None, None)
            .await
    }
    pub async fn set_rebate_ratio(
        &self,
        alpha_numerator: u32,
        alpha_denominator: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setRebateRatio",
                (alpha_numerator, alpha_denominator),
                None,
                None,
            )
            .await
    }
    pub async fn undelegate(
        &self,
        indexer: ::web3::types::Address,
        shares: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("undelegate", (indexer, shares), None, None)
            .await
    }
    pub async fn set_max_allocation_epochs(
        &self,
        max_allocation_epochs: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setMaxAllocationEpochs", max_allocation_epochs, None, None)
            .await
    }
    pub async fn close_allocation_many(
        &self,
        requests: ::solidity_bindgen::internal::Unimplemented,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("closeAllocationMany", requests, None, None)
            .await
    }
    pub async fn set_protocol_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setProtocolPercentage", percentage, None, None)
            .await
    }
    pub async fn collect(
        &self,
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("collect", (tokens, allocation_id), None, None)
            .await
    }
    pub async fn set_rewards_destination(
        &self,
        destination: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setRewardsDestination", destination, None, None)
            .await
    }
    pub async fn withdraw_delegated(
        &self,
        indexer: ::web3::types::Address,
        delegate_to_indexer: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "withdrawDelegated",
                (indexer, delegate_to_indexer),
                None,
                None,
            )
            .await
    }
    pub async fn close_allocation(
        &self,
        allocation_id: ::web3::types::Address,
        poi: [u8; 32usize],
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("closeAllocation", (allocation_id, poi), None, None)
            .await
    }
    pub async fn stake(
        &self,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("stake", tokens, None, None).await
    }
    pub async fn set_delegation_parameters_cooldown(
        &self,
        blocks: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationParametersCooldown", blocks, None, None)
            .await
    }
    pub async fn close_and_allocate(
        &self,
        closing_allocation_id: ::web3::types::Address,
        poi: [u8; 32usize],
        indexer: ::web3::types::Address,
        subgraph_deployment_id: [u8; 32usize],
        tokens: ::web3::types::U256,
        allocation_id: ::web3::types::Address,
        metadata: [u8; 32usize],
        proof: ::std::vec::Vec<u8>,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "closeAndAllocate",
                (
                    closing_allocation_id,
                    poi,
                    indexer,
                    subgraph_deployment_id,
                    tokens,
                    allocation_id,
                    metadata,
                    proof,
                ),
                None,
                None,
            )
            .await
    }
    pub async fn set_controller(
        &self,
        controller: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setController", controller, None, None)
            .await
    }
    pub async fn set_operator(
        &self,
        operator: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setOperator", (operator, allowed), None, None)
            .await
    }
    pub async fn set_asset_holder(
        &self,
        asset_holder: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setAssetHolder", (asset_holder, allowed), None, None)
            .await
    }
    pub async fn unstake(
        &self,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("unstake", tokens, None, None).await
    }
    pub async fn set_delegation_tax_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setDelegationTaxPercentage", percentage, None, None)
            .await
    }
    pub async fn set_curation_percentage(
        &self,
        percentage: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setCurationPercentage", percentage, None, None)
            .await
    }
    pub async fn set_delegation_parameters(
        &self,
        indexing_reward_cut: u32,
        query_fee_cut: u32,
        cooldown_blocks: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setDelegationParameters",
                (indexing_reward_cut, query_fee_cut, cooldown_blocks),
                None,
                None,
            )
            .await
    }
    pub async fn set_slasher(
        &self,
        slasher: ::web3::types::Address,
        allowed: bool,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("setSlasher", (slasher, allowed), None, None)
            .await
    }
    pub async fn withdraw(
        &self,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider.send("withdraw", (), None, None).await
    }
    pub async fn stake_to(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("stakeTo", (indexer, tokens), None, None)
            .await
    }
    pub async fn slash(
        &self,
        indexer: ::web3::types::Address,
        tokens: ::web3::types::U256,
        reward: ::web3::types::U256,
        beneficiary: ::web3::types::Address,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send("slash", (indexer, tokens, reward, beneficiary), None, None)
            .await
    }
    pub async fn set_delegation_unbonding_period(
        &self,
        delegation_unbonding_period: u32,
    ) -> ::std::result::Result<SolidityBindgenProvider::Out, ::web3::Error> {
        self.provider
            .send(
                "setDelegationUnbondingPeriod",
                delegation_unbonding_period,
                None,
                None,
            )
            .await
    }
}
impl<SolidityBindgenProvider> Staking<SolidityBindgenProvider>
where
    SolidityBindgenProvider: ::solidity_bindgen::CallProvider,
{
    pub async fn allocations(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::Address,
            [u8; 32usize],
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("allocations", input_0).await
    }
    pub async fn delegation_ratio(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationRatio", ()).await
    }
    pub async fn rewards_destination(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("rewardsDestination", input_0).await
    }
    pub async fn rebates(
        &self,
        input_0: ::web3::types::U256,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            u32,
            u32,
            u32,
        ),
        ::web3::Error,
    > {
        self.provider.call("rebates", input_0).await
    }
    pub async fn stakes(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("stakes", input_0).await
    }
    pub async fn slashers(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("slashers", input_0).await
    }
    pub async fn get_allocation_state(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<u8, ::web3::Error> {
        self.provider
            .call("getAllocationState", allocation_id)
            .await
    }
    pub async fn curation_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("curationPercentage", ()).await
    }
    pub async fn get_subgraph_allocated_tokens(
        &self,
        subgraph_deployment_id: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getSubgraphAllocatedTokens", subgraph_deployment_id)
            .await
    }
    pub async fn get_indexer_staked_tokens(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getIndexerStakedTokens", indexer).await
    }
    pub async fn protocol_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("protocolPercentage", ()).await
    }
    pub async fn controller(&self) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("controller", ()).await
    }
    pub async fn get_indexer_capacity(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("getIndexerCapacity", indexer).await
    }
    pub async fn get_allocation(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::Address,
            [u8; 32usize],
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("getAllocation", allocation_id).await
    }
    pub async fn asset_holders(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("assetHolders", input_0).await
    }
    pub async fn max_allocation_epochs(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("maxAllocationEpochs", ()).await
    }
    pub async fn delegation_unbonding_period(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationUnbondingPeriod", ()).await
    }
    pub async fn address_cache(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::Address, ::web3::Error> {
        self.provider.call("addressCache", input_0).await
    }
    pub async fn delegation_parameters_cooldown(
        &self,
    ) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationParametersCooldown", ()).await
    }
    pub async fn subgraph_allocations(
        &self,
        input_0: [u8; 32usize],
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("subgraphAllocations", input_0).await
    }
    pub async fn channel_dispute_epochs(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("channelDisputeEpochs", ()).await
    }
    pub async fn is_allocation(
        &self,
        allocation_id: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isAllocation", allocation_id).await
    }
    pub async fn operator_auth(
        &self,
        input_0: ::web3::types::Address,
        input_1: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("operatorAuth", (input_0, input_1)).await
    }
    pub async fn thawing_period(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("thawingPeriod", ()).await
    }
    pub async fn is_delegator(
        &self,
        indexer: ::web3::types::Address,
        delegator: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider
            .call("isDelegator", (indexer, delegator))
            .await
    }
    pub async fn is_operator(
        &self,
        operator: ::web3::types::Address,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("isOperator", (operator, indexer)).await
    }
    pub async fn minimum_indexer_stake(
        &self,
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider.call("minimumIndexerStake", ()).await
    }
    pub async fn delegation_tax_percentage(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("delegationTaxPercentage", ()).await
    }
    pub async fn get_delegation(
        &self,
        indexer: ::web3::types::Address,
        delegator: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider
            .call("getDelegation", (indexer, delegator))
            .await
    }
    pub async fn alpha_denominator(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("alphaDenominator", ()).await
    }
    pub async fn has_stake(
        &self,
        indexer: ::web3::types::Address,
    ) -> ::std::result::Result<bool, ::web3::Error> {
        self.provider.call("hasStake", indexer).await
    }
    pub async fn get_withdraweable_delegated_tokens(
        &self,
        delegation: (
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
    ) -> ::std::result::Result<::web3::types::U256, ::web3::Error> {
        self.provider
            .call("getWithdraweableDelegatedTokens", delegation)
            .await
    }
    pub async fn delegation_pools(
        &self,
        input_0: ::web3::types::Address,
    ) -> ::std::result::Result<
        (
            u32,
            u32,
            u32,
            ::web3::types::U256,
            ::web3::types::U256,
            ::web3::types::U256,
        ),
        ::web3::Error,
    > {
        self.provider.call("delegationPools", input_0).await
    }
    pub async fn alpha_numerator(&self) -> ::std::result::Result<u32, ::web3::Error> {
        self.provider.call("alphaNumerator", ()).await
    }
}
